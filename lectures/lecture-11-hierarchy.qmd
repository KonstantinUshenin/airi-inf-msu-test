---
title: "Informatics. Foundations of Software Development"
subtitle: "Lecture 11 — Key-Value Pairs and Hierarchical Data [Early Draft]"
author: "Konstantin Ushenin"
date: "2026"
---

## Plan

### Key-Value Pairs
### Hierarchical Data. JSON
### Hierarchical Data. XML


# Key-Value Pairs

## Пары ключ–значение: базовая модель конфигурации

::: columns
::: column

Примеры одного и того же паттерна в разных системах:

```text
HOST=localhost
PORT=8080
DEBUG=true
````

Словарь в коде:

```python
cfg = {"HOST": "localhost",
  "PORT": "8080",
  "DEBUG": "true"}
```

:::

::: column

**Key–Value модель**

* Конфигурация как набор пар `key -> value`
* Значения чаще всего **строки**

**Типовые сценарии**

* конфигурация приложений
* переменные окружения
* флаги/параметры запуска
* секреты (очень опасно!)

:::
:::

---

## Аргументы командной строки (CLI) и их обработка в Python

::: columns
::: column

Запуск программы с аргументами:

```bash
python app.py \
  --host localhost \
  --port 8080 --debug \
  --seed=100
````

Минимальный доступ в Python (`sys.argv`):

```python
import sys

print(sys.argv)
# ['app.py', '--host',
# 'localhost', '--port',
# '8080', '--debug', '--seed=100']
```

:::

::: column

**CLI-аргументы**

* Передаются **явно при запуске**
* Видимы в командной строке
* Не сохраняются после завершения процесса
* Подходят для: режимов работы, флагов, разовых параметров

**CLI-библиотеки для Python**

* `argparse` -- встроенный
* `click` -- через делегаты
* `Typer`, `Tyro`, `Fire` -- через Pydantic
* `docopt` -- через docstring

:::
:::

---

## Системные переменные окружения (Environment Variables)

::: columns
::: column

**Просмотр и установка (shell):**

```bash
echo "$HOME"
export DEBUG=1
export PATH="$PATH:/opt/tools/bin"
```

**Влияние на дочерние процессы:**

```bash
# только для этой команды
CUDA_VISIBLE_DEVICES=0 python app.py
# DEBUG попадёт в окружение процесса
export CUDA_VISIBLE_DEVICES=0
python app.py
```

:::

::: column

**Environment variables**

* Key–Value, хранятся в окружении процесса
* Передаются от shell → процессу → дочерним процессам
* **Всегда строки**, типы — по договорённости

**Плюсы**

* легко переопределять без изменения файлов
* удобно для деплоя/контейнеров/CI

**Минусы**

* нет структуры и типов
* секреты могут утекать в логи / дампы / дочерние процессы

:::
:::

---

## Bash: механизм  `source` / `.` (выполнение в *текущем* shell)

::: columns
::: column

```bash
# file: env.sh
export APP_ENV=dev
export DEBUG=1
```

```bash
# ничего не выведет
./env.sh
echo "$APP_ENV"
# изменяет текущее окружение
source env.sh
# то же самое: "." = source
. env.sh
echo "$APP_ENV"
```
:::

::: column

**Зачем это нужно**

* Включение переменных/функций в текущую сессию
* Так работает активация виртуального окружения Python (`virtualenv`, `conda`):

```bash
source .venv/bin/activate
# или
. .venv/bin/activate
```

**Риск**

* `source` выполняет код → требует доверия к файлу
* опасность с точкой `./aaa/script.sh` vs. `. /aaa/script.sh`

:::
:::

## `.env` файл: хранение секретов и загрузка в Python

::: columns
::: column

Пример `.env` (не коммитить в git):

```dotenv
# .env
OPENAI_API_KEY=sk-xxxxxxxxxxxxxxxxxxxx
OPENAI_PROJECT=my-project
OPENAI_BASE_URL=https://api.openai.com/v1
```

Загрузка в Python (через `python-dotenv`):

```python
from dotenv import load_dotenv
import os

# читает .env из текущей директории
load_dotenv()
api_key = os.getenv("OPENAI_API_KEY")
project = os.getenv("OPENAI_PROJECT")
```

:::

::: column

**Что такое `.env`**

* Не официальный стандарт, а **соглашение**
* Формат: `KEY=value` (+ комментарии `#` в большинстве реализаций)
* Применение:

  * локальная разработка
  * docker-compose / CI
  * быстрый перенос конфигов между окружениями

**Правила безопасности**

* `.env` добавлять в `.gitignore`
* хранить секреты отдельно от исходников
* минимум прав у токенов

:::
:::



---

## 5) `.ini` / `.cfg`: пары + секции

::: columns
::: column

Пример INI:

```ini
[server]
host = localhost
port = 8080

[auth]
token = secret
```

Чтение в Python:

```python
import configparser

cfg = configparser.ConfigParser()
cfg.read("app.ini")

host = cfg["server"]["host"]
port = int(cfg["server"]["port"])
print(host, port)
```

:::

::: column

**INI/CFG модель**

* Key–Value с секциями `[section]`
* Обычно всё читается как **строки**
* Комментарии чаще всего `;` или `#` (зависит от парсера)

**Плюсы**

* просто читать/редактировать
* удобно для небольших конфигов

**Минусы**

* типы “поверх” (нужно приводить вручную)
* нет стандартизированной вложенности
* разные реализации по-разному трактуют синтаксис

:::
:::

---

## 6) TOML: строгий конфиг для людей (типы + таблицы)

::: columns
::: column

```toml
title = "Example"

[server]
host = "localhost"
port = 8080
debug = true

[auth]
token = "secret"
```

```python
import tomllib
with open("config.toml", "rb") as f:
    cfg = tomllib.load(f)
print(cfg["server"]["port"])   # int
print(cfg["server"]["debug"])  # bool
```

:::

::: column

**Почему TOML**

* Однозначная спецификация
* Нормальная типизация:

  * int/float/bool/string
  * даты/время
  * массивы
* Таблицы `[section]` = структурированные объекты

**Плюсы**

* читаемо человеком
* удобно для конфигов инструментов (пример: `pyproject.toml`)

**Минусы**

* только данные (без вычислений)
* не предназначен для документов/разметки

:::
:::

---

## 7) TOML глубже: массивы, вложенные таблицы, “array of tables”

::: columns
::: column

Массивы и вложенность:

```toml
[build]
targets = ["linux", "macos", "windows"]

[db]
host = "localhost"
ports = [5432, 5433]

[db.credentials]
user = "alice"
pass = "secret"
```


:::

::: column

Array of tables (список объектов):

```toml
[[users]]
id = 1
name = "Alice"

[[users]]
id = 2
name = "Bob"
```

:::
:::

---

## 8) Уязвимости и риски

::: columns
::: column

Примеры опасных ситуаций:

```bash
# 1) Подмена файла, который source'ят
# если env.sh подменили → выполнение кода
source ./env.sh

# 2) Секреты утекли в репозиторий
git add .env
git commit -m "fix"
```

Утечки через дочерние процессы:

```bash
export SECRET=topsecret
# SECRET может попасть в вывод/логи/дампы
python app.py | tee log.txt
```

:::

::: column

**Главные классы рисков**

* **Code execution**: `source`, bash-конфиги, “конфиг как код”
* **Secret leakage**: случайный коммит `.env`, логирование env, дампы памяти
* **Injection**: некорректное экранирование, подстановка `$(...)`, пробелы/кавычки
* **Ambiguity**: разные парсеры INI трактуют синтаксис по-разному

**Рекомендации**

* Не `source`-ить недоверенные файлы
* `.env` всегда в `.gitignore`
* Секреты — через secret manager / CI secrets, минимум прав
* Конфиги как данные (TOML/INI) безопаснее, чем конфиги как код (bash)

:::
:::

---

## Итоги

1. Пары ключ-значения широко используются для конфигурирования выполняемых приложений
2. Методы системы: аргументы командной строки и аргументы окружения
3. Будьте осторожны с точками в консоли. Они могут быть как частью пути, так и командой `source`
4. Делайте отдельный файл конфигурации с секретными (`.env`) и не секретными параметрами (`.toml`)
5. Добавляйте `.env` в `.gitignore`.
6. Простое конфигурирование -- `.ini`/`.cfg`, современные подходы -- `.toml`


# JSON

## Зачем появился JSON и когда

::: columns
::: column

```javascript
// JavaScript object literal (2001)
var user = {
  id: 42,
  name: "Alice",
  admin: true
};
```


**Исторический контекст**

* 2001 — Дуглас Крокфорд
* JSON вырос из синтаксиса JavaScript
* Реакция на сложность XML (namespaces, XSD, XPath)

:::

::: column

**Цель JSON**

* Лёгкий формат обмена данными
* Минимум синтаксиса
* Прямое отображение в структуры языков

**Ключевая идея**

* JSON проектировался **для программ**, не для документов
* API > контракты > строгая типизация

:::
:::


---

## Типы данных JSON

::: columns
::: column

```json
{
  "id": 42,
  "name": "Alice",
  "admin": true,
  "score": 12.5,
  "tags": ["a", "b"],
  "meta": null,
  "data": {"comment": "Hi, Alice!"}
}
```

:::

::: column

**Поддерживаемые типы**

* object
* array
* string
* number
* boolean
* null

**Чего НЕТ**

* дат
* байтов, бинарных блоков
* пользовательских типов
* комментариев

**Следствие**

* Типы простые и универсальные
* Всё сложное — по договорённости

:::
:::

---

## Base64: кодирование бинарных данных в текст

::: columns
::: column

Бинарные данные → Base64:

```text
bytes:   48 65 6c 6c 6f
ASCII:   H  e  l  l  o
Base64:  SGVsbG8=
```
Передача в текстовом формате:

```json
{"payload": "SGVsbG8="}
```

Python-пример:

```python
import base64
data = b"Hello"
encoded = base64.b64encode(data)
decoded = base64.b64decode(encoded)
print(encoded)  # b'SGVsbG8='
print(decoded)  # b'Hello'
```

:::

::: column

**Что такое Base64**

* Способ представить **произвольные байты** в виде ASCII-текста
* Использует алфавит из 64 символов:
  `A–Z a–z 0–9 + /`
* `=` — padding для выравнивания

**Зачем нужен**

* Base64 используют, когда нужно передать **байты через текстовый канал**
* JSON / YAML / XML
* HTTP / headers
* env / `.env`
* системы, где допустим только текст

**Важно понимать**

* Base64 — не шифрует и не сжимает
* Размер увеличивается примерно на **33%**

:::
:::

---

## Строгость и синтаксис JSON

::: columns
::: column

```json
{
  "a": 1,
  "b": 2
}
```

❌ Ошибки:

```json
{ a: 1 }        // ключ без кавычек
{ "a": 1, }     // trailing comma
```

:::

::: column

**Синтаксические правила**

* Ключи — **только строки**
* Кавычки — только `"`
* Нет комментариев и висячих запятых

**Строгость JSON**

* Синтаксис проще XML
* Увеличение памяти за разметку не очень значительное. Используйте JSON-minifier для удаления пробелов и переносов строк
* Парсер **не прощает ошибок**
* JSON "легко" читать. Используйте ppring и JSON-beautifier для упрощения

:::
:::

---

## JSON Schema: зачем нужна

::: columns
::: column

```json
{
  "age": "abc"
}
```

```json
{
  "type": "object",
  "properties": {
    "age": {
      "type": "integer",
      "minimum": 0
    }
  },
  "required": ["age"]
}
```

:::

::: column

**JSON Schema**

* Описывает структуру JSON
* Проверяет типы и ограничения
* Используется в API и конфигурациях

**Возможности**

* `type`
* `properties`
* `required`
* `minimum / maximum`
* `enum`
* `array / items`

**Контраст с XML**

* JSON Schema появилась **после JSON**
* Не является обязательной частью формата

:::
:::

---

## BSON: бинарное представление JSON-подобных данных

::: columns
::: column

```json
{
  "name": "Alice",
  "age": 30,
  "admin": true
}
```

```text
field "name"   -> type:string -> length -> bytes
field "age"    -> type:int32  -> 4 bytes
field "admin"  -> type:bool   -> 1 byte
```

```text
27 00 00 00
02 6e 61 6d 65 00 06 00 00 00 41 6c 69 63 65 00
10 61 67 65 00 1e 00 00 00
08 61 64 6d 69 6e 00 01
00
```

:::

::: column

**Что такое BSON**

* Binary JSON (расширение идей JSON)
* Плюсы: эффективен для хранения и передачи, типы не теряются, быстро читается машиной
* Минусы: не человеко-читаем, больше накладные расходы, чем у JSON, не предназначен для конфигов

:::
:::

---



## YAML: назначение и общая модель данных

::: columns
::: column

```json
{"user": {"id": 42, "name": "Alice", "admin": true}}
```

```yaml
user:
  id: 42
  name: Alice
  admin: true
````

:::

::: column

**Что такое YAML**

* YAML Ain’t Markup Language
* Формат конфигурации, ориентированный на человека
* Представляет **структурированные данные**, а не документы

**Модель данных**

* mapping (словарь)
* sequence (список)
* scalar (значение)

**Эквивалентность**

* YAML — надмножество JSON
* Любой корректный JSON — корректный YAML

:::
:::

---

## Списки (sequences) и словари (mappings) в YAML

::: columns
::: column

```yaml
items:
  - apple
  - banana
  - orange
```

Список словарей:

```yaml
users:
  - id: 1
    name: Alice
  - id: 2
    name: Bob
```

Inline-форма

```yaml
items: [a, b, c]
```

Списки

* Обозначаются через `-`
* Отступ определяет уровень вложенности
* Порядок элементов сохраняется

:::

::: column

```yaml
server:
  host: localhost
  port: 8080
```

Inline-форма:

```yaml
server: { host: localhost, port: 8080 }
```

Cловари

* Ключ -> значение
* Пробел после `:` обязателен
* Ключи обычно строки


:::
:::

---

## Строки в YAML: кавычки и неявная типизация

::: columns
::: column

```yaml
a: hello
b: "hello"
c: 'hello'
```

Опасные значения:

```yaml
yes: yes
no: no
on: on
off: off
```

:::

::: column

**Строки**

* Без кавычек — разрешено
* `'...'` — без экранирования
* `"..."` — с экранированием (`\n`, `\t`)

**Неявная типизация**

* `yes`, `no`, `on`, `off` → boolean
* `123` → int
* `12.5` → float

**Рекомендация**

> В важных конфигах
> **явно использовать кавычки**

:::
:::

---

## Длинные тексты: block scalars (`|` и `>`)

::: columns
::: column

Literal block:

```yaml
text: |
  line one
  line two
```

Folded block:

```yaml
text: >
  line one
  line two
```

:::

::: column

**Literal (`|`)**

* Переводы строк **сохраняются**
* Используется для:

  * логов
  * SQL
  * скриптов
  * конфигов с текстом

Результат:

```
"line one\nline two\n"
```

**Folded (`>`)**

* Переводы строк -> пробелы
* Удобно для длинных описаний

Результат:

```
"line one line two\n"
```

:::
:::

---

## Комментарии, null и якоря

::: columns
::: column

```yaml
# Комментарий
value: null
other: ~

defaults: &base
  timeout: 30
  retries: 3

service:
  <<: *base
  timeout: 60
```

:::

::: column

**Комментарии**

* `#` до конца строки
* Разрешены почти везде

**Null**

* `null`, `~`, пустое значение

**Anchors & aliases**

* `&name` — якорь
* `*name` — ссылка
* `<<` — merge

**Опасность**

* Якоря усложняют анализ
* Не все инструменты поддерживают одинаково

:::
:::

---

## JSON в Python

::: columns
::: column

```python
import json

text = '{"id": 42, "name": "Alice"}'

data = json.loads(text)
print(data["id"])      # 42

data["admin"] = True

print(json.dumps(data))
```

:::

::: column

**Модель работы**

* JSON → dict / list
* Без промежуточного DOM или XPath запросов

**Функции**

* `json.loads()` — строка → объект
* `json.load()` — файл → объект
* `json.dumps()` — объект → строка

**Ключевое отличие от XML**

* JSON естественно ложится в модель языка
* Минимум инфраструктуры

:::
:::


---

## Соответствие типов: JSON, Python, JavaScript

::: columns
::: column

| JSON | Python | JavaScript |
|-----|--------|------------|
| object | dict | Object |
| array | list | Array |
| string | str | string |
| number | int / float | number |
| boolean | bool | boolean |
| null | None | null |
| — | set | Set |

:::

::: column

**Ключевая идея**

* JSON — минимальная модель данных
* Типы подбирались под **языки программирования**, но не совпадают полностью

**Критичное отличие**

* В JSON **НЕТ множества (set)**
* Нет уникальности элементов
* Нет неупорядоченных коллекций

**Следствие**

* `set` в Python при сериализации → `array`
* Семантика уникальности теряется
* Восстановление `set` — по договорённости

:::
:::

---

## Потеря информации при JSON-сериализации (пример)

::: columns
::: column

```python
data = { # Python set
    "tags": {"a", "b", "c"}
}

import json
print(json.dumps(data))
````

Результат:

```json
{
  "tags": ["a", "b", "c"]
}
```

:::

::: column

**Что произошло**

* `set` преобразован в `array`
* Порядок не гарантирован
* Уникальность — не зафиксирована

**Почему так**

* JSON не знает про множества
* JSON — формат передачи, а не типовая система

**Практика**

* Использовать `array`
* Или явно кодировать тип:

  ```json
  {"type": "set", "values": [...]}
  ```

:::
:::


# XML


## XML: назначение и версии стандарта

::: columns
::: column

```xml
<?xml version="1.0" encoding="UTF-8"?>
<user id="42" role="admin">
  <name>Alice</name>
  <email>alice@example.com</email>
</user>
```

* Текстовый формат для описания **структурированных данных**
* XML описывает **форму**, а не смысл данных
* XML — **метаязык** (основа для SVG, SOAP, RSS и др.)


:::

::: column

**Назначение XML**


**Версии стандарта**

* **XML 1.0** — стандарт де-факто
* **XML 1.1** — отличается только набором допустимых символов
* Большинство парсеров и форматов ожидают XML 1.0

**Практика**

* Почти всегда используйте `version="1.0"`
* XML 1.1 может не поддерживаться инфраструктурой

:::
:::

---

## Структура XML-документа

::: columns
::: column

```xml
<?xml version="1.0"?>
<document>
  <header>
    <title>Example</title>
  </header>
  <body/>
</document>
```

:::

::: column

**Обязательные элементы XML**

* XML-декларация (опциональна, но рекомендуется)
* **Ровно один корневой элемент**
* Вложенные элементы образуют **дерево**

**Структурные правила**

* XML — всегда **иерархия**/**дерево**, не граф
* Порядок элементов важен
* Переводы строк и пробелы могут быть
  текстовыми узлами
* XML нельзя “починить автоматически”. Любое нарушение структуры — фатальная ошибка

:::
:::

---

## Элементы и атрибуты XML

::: columns
::: column

```xml
<user id="42" role="admin">
  <name>Alice</name>
  <email>alice@example.com</email>
</user>
```


**Элементы**

* Основная структурная единица XML
* Состоят из:

  * открывающего тега
  * содержимого
  * закрывающего тега
* Возможны пустые элементы: `<br/>`


:::

::: column

**Атрибуты**

* Формат: `name="value"`
* Значения **всегда строки**
* Один атрибут не может повторяться
* Теги могут повторяться внутри тега

**Рекомендованная семантика**

* Данные → **элементы**
* Метаданные → **атрибуты**

:::
:::

---

## Комментарии и текстовое содержимое

::: columns
::: column

```xml
<!-- user record -->
<expr>a &lt; b &amp;&amp; b &gt; c</expr>
```

**Комментарии**

* Синтаксис: `<!-- ... -->`
* Игнорируются парсером
* Запрещено:

  * вложенные комментарии
  * последовательность `--`

:::

::: column

**Текстовое содержимое (PCDATA)**

* `<`, `&` запрещены напрямую
* Используется экранирование:

  * `&lt;` `<`
  * `&gt;` `>`
  * `&amp;` `&`

**Важно**

* XML **не угадывает** намерения автора
* Неверный символ → ошибка парсинга

:::
:::

---

## CDATA: необрабатываемый текст

::: columns
::: column

```xml
<script><![CDATA[
  if (a < b && b > c) {
      return 0;
  }
]]></script>
```

**CDATA-секция**

* Текст внутри **не анализируется**
* Все символы допустимы, кроме `]]>`
* Полезно для:

  * кода
  * SQL
  * шаблонов

:::

::: column

**Ограничения**

* Нельзя вкладывать CDATA
* Содержимое не нормализуется
* Усложняет обработку XPath и поиск

**Выбор**

* Escaping — безопаснее
* CDATA — удобнее, но грубее

:::
:::


---

## Пространства имён XML: зачем и что это такое

::: columns
::: column

```xml
<book>
  <title>XML</title>
</book>
````

```xml
<svg>
  <title>Circle</title>
</svg>
```

:::

::: column

**Проблема без namespaces**

* Одинаковые имена элементов
* Разные смыслы
* Конфликт словарей тегов

**Решение XML**

* Пространство имён задаёт **контекст имени**
* Имя элемента = **(namespace URI, local-name)**
* Namespace идентифицируется URI, а не префиксом

**Следствие**

* `<title>` без namespace — неоднозначен
* XML не знает «семантики» без namespace

:::
:::

---

## Объявление пространства имён

::: columns
::: column

```xml
<book xmlns="urn:book">
  <title>XML</title>
</book>
```

```xml
<b:book xmlns:b="urn:book">
  <b:title>XML</b:title>
</b:book>
```

:::

::: column

**Два способа объявления**

* Default namespace:

  ```xml
  xmlns="urn:book"
  ```
* Namespace с префиксом:

  ```xml
  xmlns:b="urn:book"
  ```

**Ключевые правила**

* Префикс — **алиас**
* Важен **URI**
* Разные префиксы с одним URI — эквивалентны

**Фактически**

* `{urn:book}title`
* `{urn:book}book`

:::
:::

---

## Наследование и переопределение namespace

::: columns
::: column

```xml
<root xmlns="urn:A">
  <x/>
  <inner xmlns="urn:B">
    <x/>
  </inner>
  <x/>
</root>
```

:::

::: column

**Область действия namespace**

* Namespace действует:

  * на элемент
  * на всех его потомков

**Переопределение**

* Вложенный элемент может задать новый namespace
* После выхода из области — старый namespace восстанавливается

**Namespace элементов**

* `<root>` → `urn:A`
* первый `<x>` → `urn:A`
* `<inner>` и его `<x>` → `urn:B`
* последний `<x>` → `urn:A`

:::
:::

---

## Атрибуты и пространства имён (важная ловушка)

::: columns
::: column

```xml
<item xmlns="urn:A" id="10"/>
```

```xml
<item xmlns:a="urn:A" a:id="10"/>
```

:::

::: column

**Ключевое правило XML**

* Default namespace **НЕ применяется** к атрибутам

**Разбор примеров**

1. `<item xmlns="urn:A" id="10"/>`

   * элемент: `{urn:A}item`
   * атрибут: `{""}id` (без namespace)

2. `<item a:id="10"/>`

   * атрибут: `{urn:A}id`

**Следствие**

* Namespace атрибута возможен **только через префикс**
* Частая причина ошибок в XPath и XSD

:::
:::

---

## XPath: идея и модель навигации

::: columns
::: column

```xml
<book>
  <title>XML</title>
  <author>Smith</author>
</book>
```

:::

::: column

**XPath**

* Язык навигации по XML-дереву
* Работает с логической моделью XML
* Используется в:

  * XPath
  * XSLT
  * XSD
  * XML-парсерах

**Модель**

* XML = дерево узлов
* XPath = путь в дереве

**Типы узлов**

* element
* attribute
* text
* root

:::
:::

---

## XPath: базовый синтаксис путей

::: columns
::: column

```xpath
/book/title
//title
```

:::

::: column

**Основные конструкции**

* `/` — абсолютный путь от корня
* `//` — поиск в любом месте поддерева
* `name` — элемент с данным именем

**Примеры**

* `/book/title` — строго по структуре
* `//title` — любой `<title>` в документе

**Важно**

* XPath чувствителен к namespace
* Совпадение имени ≠ совпадение элемента

:::
:::

---

## XPath: атрибуты и предикаты

::: columns
::: column

```xpath
//user[@role="admin"]
/book[@id="42"]
```

:::

::: column

**Атрибуты**

* Обращение через `@`
* Используются в предикатах

**Предикаты**

* Фильтрация узлов
* Синтаксис: `[условие]`

**Типичные условия**

* `@attr = "value"`
* `position()`
* `last()`

:::
:::

---

## XPath: текстовые узлы и функции

::: columns
::: column

```xpath
/book/title/text()
contains(., "XML")
```

:::

::: column

**Текстовые узлы**

* `text()` возвращает текст элемента
* Элемент и текст — разные узлы

**Функции XPath**

* `contains()`
* `starts-with()`
* `normalize-space()`

**Важно**

* `.` — текущий узел
* XPath работает с узлами, не со строками

:::
:::

---

## XPath и пространства имён

::: columns
::: column

```xml
<book xmlns="urn:book">
  <title>XML</title>
</book>
```

```xpath
/book/title        <!-- НЕ работает -->
```

```xpath
/b:book/b:title    <!-- работает -->
```

:::

::: column

**Ключевое правило**

* XPath **не видит default namespace**

**Обязательное действие**

* Связать префикс с URI:

  ```
  b → urn:book
  ```

**Следствие**

* Любой XPath с namespace требует префиксов
* Самая частая причина “XPath ничего не находит”

:::
:::

---



## Parsing vs Validation в XML

::: columns
::: column

```xml
<user>
  <age>abc</age>
</user>
````

:::

::: column

**Parsing (разбор)**

* Проверяет только **синтаксис**
* XML должен быть **well-formed**
* Ошибка структуры → фатальная ошибка

**Validation (валидация)**

* Проверяет соответствие **схеме**
* Типы, порядок, кратность
* Требует XSD (или DTD)

**Ключевое различие**

* Well-formed ≠ Valid
* Парсер может принять XML,
  который схема отвергнет

:::
:::

---

## XML Schema (XSD): назначение и роль

::: columns
::: column

```xml
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
</xs:schema>
```

:::

::: column

**XML Schema (XSD)**

* Формальный контракт XML-документа
* Описывает:

  * допустимые элементы
  * их типы
  * структуру и порядок

**Зачем нужна XSD**

* Раннее обнаружение ошибок
* Типизация данных
* Генерация кода (Java, C#, …)

**Важно**

* XSD — отдельный стандарт
* XML сам по себе **не типизирован**

:::
:::

---

## XSD: элементы и типы

::: columns
::: column

```xml
<xs:element name="age" type="xs:int"/>
<xs:element name="name" type="xs:string"/>
```

:::

::: column

**Элементы XSD**

* `xs:element` — XML-элемент
* `type` — встроенный или пользовательский тип

**Простые типы**

* `xs:string`
* `xs:int`, `xs:integer`
* `xs:boolean`
* `xs:date`, `xs:dateTime`

**Следствие**

* `<age>abc</age>` — ошибка при `xs:int`
* Типы проверяются при validation

:::
:::

---

## XSD: complexType и sequence

::: columns
::: column

```xml
<xs:element name="user">
  <xs:complexType>
    <xs:sequence>
      <xs:element name="name" type="xs:string"/>
      <xs:element name="age"  type="xs:int"/>
    </xs:sequence>
  </xs:complexType>
</xs:element>
```

:::

::: column

**complexType**

* Элемент с вложенной структурой
* Может содержать элементы и атрибуты

**xs:sequence**

* Строгий порядок элементов
* `<age>` до `<name>` → ошибка

**Альтернативы**

* `xs:choice` — один из вариантов
* `xs:all` — любой порядок (0/1 раз)

:::
:::

---

## XSD: атрибуты, кратность и ограничения

::: columns
::: column

```xml
<xs:attribute name="id"
              type="xs:int"
              use="required"/>

<xs:element name="item"
            minOccurs="0"
            maxOccurs="unbounded"/>
```

:::

::: column

**Атрибуты**

* `xs:attribute`
* `use="required | optional"`

**Кратность**

* `minOccurs`
* `maxOccurs`
* `unbounded` — без ограничения

**Ограничения (restriction)**

* диапазоны чисел
* перечисления (enum)
* шаблоны (pattern)

:::
:::

---

## XSD: перечисления и диапазоны

::: columns
::: column

```xml
<xs:simpleType name="Role">
  <xs:restriction base="xs:string">
    <xs:enumeration value="admin"/>
    <xs:enumeration value="user"/>
  </xs:restriction>
</xs:simpleType>
```

:::

::: column

**Перечисления**

* Ограниченный набор значений
* Часто используется для ролей, статусов

**Диапазоны**

* `minInclusive / maxInclusive`
* `minExclusive / maxExclusive`

**Следствие**

* XML становится строго типизированным
* Ошибки ловятся до бизнес-логики

:::
:::

---

## Связь XML и XSD (schemaLocation)

::: columns
::: column

```xml
<user
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="user.xsd">
</user>
```

:::

::: column

**Подключение схемы**

* `xsi:noNamespaceSchemaLocation`
* `xsi:schemaLocation` (с namespace)

**Важно**

* XML **может** указывать схему
* Но **обязанность валидации** — у парсера

**Практика**

* Не все парсеры валидируют автоматически
* Часто validation включают явно

:::
:::

---

## XML в памяти: DOM и SAX

::: columns
::: column

```xml
<root>
  <user id="1"/>
  <user id="2"/>
</root>
```

:::

::: column

**Две модели обработки**

* **DOM** — всё дерево в памяти
* **SAX** — поток событий

**Выбор модели**

* DOM — удобство и навигация
* SAX — производительность и масштаб

**Ключевая идея**

* XML логически — дерево
* Но физически можно читать по-разному

:::
:::

---

## DOM: модель и свойства

::: columns
::: column

```text
Document
└── Element(root)
    ├── Element(user)
    └── Element(user)
```

:::

::: column

**DOM (Document Object Model)**

* Загружает **весь документ**
* Представляет XML как объектное дерево

**Плюсы**

* Удобная навигация
* Можно изменять структуру

**Минусы**

* Память O(n)
* Плохо для больших файлов

:::
:::

---

## SAX: потоковая модель

::: columns
::: column

```text
startElement(root)
startElement(user)
endElement(user)
startElement(user)
endElement(user)
endElement(root)
```

:::

::: column

**SAX (event-based)**

* Чтение XML как потока
* Генерирует события:

  * startElement
  * characters
  * endElement

**Плюсы**

* Минимум памяти
* Подходит для больших XML

**Минусы**

* Нет случайного доступа
* Сложнее логика обработки

:::
:::

---

## DOM vs SAX: сравнение

::: columns
::: column

```text
DOM:  дерево целиком
SAX:  поток событий
```

:::

::: column

**DOM**

* * Удобство
* * XPath
* − Память
* − Медленно для больших файлов

**SAX**

* * Быстро
* * Мало памяти
* − Сложно
* − Только однонаправленный проход

**Правило**

* Малый XML → DOM
* Большой XML → SAX / streaming

:::
:::


---

## Python: XML как дерево (ElementTree: parse/fromstring)

::: columns
::: column

```python
import xml.etree.ElementTree as ET

xml = """<root>
  <user id="42" role="admin">
    <name>Alice</name>
  </user>
</root>"""

root = ET.fromstring(xml)

user = root.find("user")
print(user.attrib["id"])         # 42
print(user.find("name").text)    # Alice
````

:::

::: column

**ElementTree (DOM-подобная модель)**

* `ET.fromstring()` — парсинг строки
* `ET.parse()` — парсинг файла → `tree.getroot()`
* `find()/findall()` — поиск по тегам (простые XPath)

**Узлы и данные**

* `element.tag` — имя элемента
* `element.attrib` — словарь атрибутов
* `element.text` — текстовое содержимое

**Типичные ошибки**

* `find("a/b")` ищет по *пути*, но это **подмножество XPath**
* Пробелы/переводы строк могут давать `text` с whitespace

:::
:::

---

## Python: XPath-подмножество и фильтрация (предикаты)

::: columns
::: column

```python
import xml.etree.ElementTree as ET

root = ET.fromstring("""
<root>
  <user id="1" role="user"/>
  <user id="2" role="admin"/>
  <user id="3" role="admin"/>
</root>
""")

admins = root.findall(".//user[@role='admin']")
print([u.attrib["id"] for u in admins])  # ['2', '3']
```

:::

::: column

**XPath в ElementTree**

* Поддерживается ограниченный синтаксис:

  * `.//tag`
  * `tag/subtag`
  * `[@attr='value']`

**Что удобно показывать на лекции**

* Фильтрация по атрибутам
* Поиск по документу через `.//`

**Ограничения**

* Нет полной поддержки осей XPath (`ancestor::`, `following-sibling::`)
* Для сложного XPath обычно используют `lxml`

:::
:::

---

## Python: namespaces в ElementTree (как искать элементы)

::: columns
::: column

```python
import xml.etree.ElementTree as ET

root = ET.fromstring("""
<book xmlns="urn:book">
  <title>XML</title>
</book>
""")

ns = {"b": "urn:book"}

# без namespace не найдёт
print(root.find("title"))  # None

# правильный поиск: префикс + словарь
print(root.find("b:title", ns).text)  # XML
```

:::

::: column

**Ключевой момент**

* Внутри XML элементы в namespace
* Поиск должен использовать **qualified name**

**Как это делается**

* Словарь `ns = {"prefix": "URI"}`
* Поиск с префиксом: `"b:title"`

**Что объяснить словами**

* Default namespace в XML ≠ “нет namespace”
* Префикс в Python — технический алиас, важен URI

:::
:::

---

## Python: потоковая обработка больших XML (iterparse)

::: columns
::: column

```python
import xml.etree.ElementTree as ET

# читаем огромный XML без загрузки всего в память
for event, el in ET.iterparse("big.xml", events=("end",)):
    if el.tag == "item":
        # обработка элемента
        # ...
        el.clear()   # освобождаем память под уже обработанным поддеревом
```

:::

::: column

**Streaming-подход (SAX-like)**

* `iterparse()` — чтение по частям
* События `start/end` позволяют обработку “на лету”
* `el.clear()` критичен: иначе память растёт

**Когда применять**

* Логи, дампы, выгрузки (GB)
* ETL-пайплайны

**Ограничения**

* Нет “случайного доступа” как в DOM
* Логику приходится строить вокруг событий

:::
:::

---

## SVG: XML для векторной графики (namespace обязателен)

::: columns
::: column

```xml
<svg xmlns="http://www.w3.org/2000/svg"
     width="120" height="120" viewBox="0 0 120 120">
  <circle cx="60" cy="60" r="45" fill="red"/>
</svg>
```

:::

::: column

**Почему SVG хороший пример “XML в реальности”**

* Полноценный “язык поверх XML”
* Сильная зависимость от **namespaces**
* Теги = примитивы, атрибуты = параметры

**Что подчеркнуть**

* `xmlns="http://www.w3.org/2000/svg"` обязателен для корректной идентификации
* SVG легко генерировать программно (шаблоны, пайплайны)

**Связь с темой**

* Пример: тот же синтаксис XML, но другой смысл

:::
:::

---

## SVG: группы, трансформации, стили (чуть сложнее)

::: columns
::: column

```xml
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 60">
  <g transform="translate(10,10)">
    <rect x="0" y="0" width="80" height="40" fill="none" stroke="black"/>
    <text x="5" y="25" font-size="12">Hello</text>
  </g>
</svg>
```

:::

::: column

**Полезные конструкции SVG**

* `<g>` — группировка элементов
* `transform` — трансформации (translate/scale/rotate)
* `<text>` — текст (но с нюансами шрифтов/рендеринга)

**Что обсудить на лекции**

* SVG = дерево → удобно применять XPath/DOM
* Визуальные параметры обычно в атрибутах

**Ловушки**

* Рендеринг текста зависит от окружения
* Стили можно выносить в CSS, но это отдельная тема

:::
:::

---

## SOAP: XML как протокол сообщений (Envelope/Header/Body)

::: columns
::: column

```xml
<soap:Envelope
  xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
  xmlns:m="urn:msg">

  <soap:Header>
    <m:AuthToken>abc123</m:AuthToken>
  </soap:Header>

  <soap:Body>
    <m:GetUser>
      <m:id>42</m:id>
    </m:GetUser>
  </soap:Body>

</soap:Envelope>
```

:::

::: column

**SOAP-структура**

* `Envelope` — контейнер сообщения
* `Header` — метаданные (аутентификация, трейсинг, маршрутизация)
* `Body` — полезная нагрузка (RPC/документ)

**Почему здесь важны namespaces**

* SOAP элементы должны быть в SOAP namespace
* Payload обычно в отдельном namespace (`m:`)

**Связь с XSD**

* Часто схема описывает типы для `Body`
* WSDL использует XSD для контрактов

:::
:::

---

## SOAP Fault: стандартная ошибка протокола

::: columns
::: column

```xml
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <soap:Fault>
      <faultcode>soap:Client</faultcode>
      <faultstring>Invalid id</faultstring>
    </soap:Fault>
  </soap:Body>
</soap:Envelope>
```

:::

::: column

**Fault**

* Стандартизированная форма ошибки
* Часто полезно для логирования и автоматической обработки

**Типовые причины**

* Ошибка клиента (неверные данные)
* Ошибка сервера (исключение на стороне сервиса)

**Учебный смысл**

* XML может быть не “данными”, а **протоколом**
* Формальная структура важна для совместимости

:::
:::

---

## Итог: что нужно помнить про XML

::: columns
::: column

```text
XML ecosystem:
  XML + Namespaces + XPath
  + (XSD validation)
  + (DOM/SAX processing)
  -> SVG / SOAP / RSS / ...
```

:::

::: column

**Ключевые идеи**

* XML — **метаязык**: смысл задают форматы поверх него
* XML — **строгий**: парсер не “чинит” ошибки
* Namespace = (URI, local-name), префикс — алиас
* XPath — навигация по дереву, но namespaces обязательны
* Parsing ≠ Validation (well-formed ≠ valid)
* DOM удобно, SAX/streaming масштабируется

**Практические выводы**

* Малые документы → DOM/ElementTree
* Большие выгрузки → streaming (`iterparse`)
* Протоколы/контракты → XSD рядом почти всегда

:::
:::

---

## JSON vs XML — принципиальные отличия

::: columns
::: column

| XML                     | JSON                      |
| ----------------------- | ------------------------- |
| Дерево элементов        | Объекты и массивы         |
| Элементы + атрибуты     | Только ключ–значение      |
| Всё — строки            | Типы данных               |
| Namespaces              | Нет                       |
| XSD — жёсткий контракт  | JSON Schema — опциональна |
| Подходит для документов | Подходит для API          |
| Многословный            | Компактный                |

:::

::: column

**Ключевые различия**

* XML — **формальный и расширяемый**
* JSON — **простой и практичный**

**Философия**

* XML → контракт и стабильность
* JSON → удобство и скорость разработки

**Важно**

* JSON не «лучше»
* JSON решает **другой класс задач**

:::
:::


