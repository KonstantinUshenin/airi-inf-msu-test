---
title: "Informatics. Foundations of Software Development"
subtitle: "Lecture 10 ‚Äî Text data [EARLY DRAFT]"
author: "Konstantin Ushenin"
date: "2026"
---

## Plan

### Encoding
### String in Memory
### Regular Expressions

**–î–ª—è –∞–≤—Ç–æ—Ä–æ–≤. –ó–∞–º–µ—Ç–∫–∏:**

- Code point ‚Üí ¬´–∫–æ–¥–æ–≤–∞—è —Ç–æ—á–∫–∞¬ª (—É—Å—Ç–æ—è–≤—à–∏–π—Å—è –ø–µ—Ä–µ–≤–æ–¥)
- –î–æ–±–∞–≤–ª–µ–Ω—ã: –ø—Ä–∏–º–µ—Ä—ã UTF-8 –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è, grapheme clusters, Unicode normalization, BOM
- –î–æ–±–∞–≤–ª–µ–Ω—ã: DFA/NFA/backtracking engines, ReDoS, lookahead/lookbehind, named groups
- –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å: –¥–∏–∞–≥—Ä–∞–º–º—ã –¥–ª—è NFA/DFA, –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã regex

# Encoding


## Binary-Coded Decimal (BCD) ‚Äî 1950s

::: columns
::: column

- Idea
  - Decimal digits encoded separately
  - One digit ‚Üí one 4-bit nibble
  - No positional binary value across digits

- Encoding rules
  - `0‚Äì9` ‚Üí valid
  - `1010‚Äì1111` ‚Üí invalid / reserved

:::

::: column

| Decimal | BCD (binary) | Hex |
|--------:|--------------|-----|
| 0 | 0000 | 0x0 |
| 1 | 0001 | 0x1 |
| 2 | 0010 | 0x2 |
| 3 | 0011 | 0x3 |
| 4 | 0100 | 0x4 |
| 5 | 0101 | 0x5 |
| 6 | 0110 | 0x6 |
| 7 | 0111 | 0x7 |
| 8 | 1000 | 0x8 |
| 9 | 1001 | 0x9 |

:::
:::

---

## Morse Code ‚Äî 1830s‚Äì1840s

::: columns
::: column

- Type
  - Variable-length code
  - Time-based (dots and dashes)
  - Not binary in storage sense

- Encoding
  - Short signals for frequent letters
  - Long signals for rare letters
  - Explicit symbol boundaries (pauses)

- Properties
  - Human-decodable
  - No fixed symbol width
  - Optimized for manual transmission

- Usage
  - Telegraphy
  - Radio communication
  - Emergency signaling

:::

::: column

![](images/International_Morse_Code.png)

:::
:::

---

## ITA2 / Baudot‚ÄìMurray Code ‚Äî 1930s

::: columns
::: column

- Type
  - Fixed-length binary code
  - 5 bits ‚Üí 32 code points

- Control symbols
  - LTRS / FIGS ‚Äî mode shift control codes
  - CR (Carriage Return) ‚Äî move to line start
  - LF (Line Feed) ‚Äî move to next line

- Decoding
  - Context-dependent
  - Same bit pattern ‚Üí different symbol
  - Mode persists until next shift

:::

::: column

![](images/Ita2.png)

:::
:::

---


## What types of encodings exist?

- **Number of bits per symbol**: 4, 5, 7, 8, 16, ‚Ä¶
  - Examples: BCD (4), Baudot (5), ASCII (7), Latin-1 (8), UTF-16 (16)

- **Fixed-length vs variable-length**
  - Fixed-length: BCD, Baudot, ASCII
  - Variable-length: Morse code, UTF-8

- **Control symbols**
  - Explicit control codes: Baudot (LTRS / FIGS), ASCII (CR, LF, ESC)
  - Implicit control via structure: Morse code (pauses)
  
---

## American Standard Code for Information Interchange (ASCII) ‚Äî 1963

![](images/ASCII_Code_Chart.png)

---

## ASCII ‚Äî 1963

::: columns
::: column

- Control characters
  - `0‚Äì31`, `127`
  - Non-printing (`CR`, `LF`, `ESC`)

- Letters
  - `A‚ÄìZ`: `65‚Äì90`
  - `a‚Äìz`: `97‚Äì122`

**Notes**

- Character ranges are non-contiguous
- Uppercase and lowercase letters have
  - Fixed offset (`+32`)
  - Equal distance in the code table

:::

::: column

- Punctuation ranges

  - `33‚Äì47`: `! " # $ % & ' ( ) * + , - . /`
  - `58‚Äì64`: `: ; < = > ? @`
  - `91‚Äì96`: `[ \ ] ^ _ \``
  - `123‚Äì126`: `{ | } ~`

:::
:::

---

## ASCII Control Characters (Key Ones)

::: columns
::: column

BS (Backspace, 0x08)

 - Moves cursor one position left
 - Overwrites previous character
 - Used on teletypes for character composition

CR (Carriage Return, 0x0D)

 - Move cursor to start of line

LF (Line Feed, 0x0A)

 - Move cursor to next line

ESC (Escape, 0x1B)

 - Starts control sequences
 - Basis for ANSI terminal commands

DEL (Delete, 0x7F)

 - Erase character (historical)

:::

::: column

Diacritic composition using BS

- `a BS ' ‚Üí √°`
- `a BS \ ‚Üí √†`
- `a BS ^ ‚Üí √¢`
- `a BS " ‚Üí √§`
- `o BS / ‚Üí √∏`
- `c BS , ‚Üí √ß`
- `n BS ~ ‚Üí √±`

Neutral / no-op cases

- `a BS a ‚Üí a`
- `a BS _ ‚Üí a`

Idea

- Diacritics were created by overprinting
- No dedicated accented characters in ASCII

:::
:::

---

## Encoding (CP866 and Windows-1251)

::: columns
::: column

![](images/CP866.png)

:::

::: column

![](images/Windows-1251.png)

:::
:::

- –°–∏–º–≤–æ–ª—ã –æ—Ç 0x00 –¥–æ 0x7F ‚Äî ASCII –∏ –æ–±—ã—á–Ω–æ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã. 0x80-0xFF ‚Äî –∑–∞–¥–∞—ë—Ç—Å—è –Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π —á–∞—Å—Ç—å—é —Ç–∞–±–ª–∏—Ü—ã –∫–æ–¥–∏—Ä–æ–≤–∫–∏
- –ö–æ–¥–∏—Ä–æ–≤–æ–∫ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–æ—Ç–µ–Ω. –†–∞–∑–Ω–∏—Ü–∞ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–∞—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –¥–∞–∂–µ –≤ –æ–¥–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ –º–æ–≥–ª–∞ –±—ã—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π
- –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏ –ò–Ω—Ç–µ—Ä–Ω–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü –æ—Å—Ç–∞–≤–∞–ª–æ—Å—å –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–º

---

## Terminal User Interface

::: columns
::: column

![](images/mc.png)

:::

::: column

![](images/htop.png)

:::
:::

- –ü–æ—è–≤–ª–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–æ–≤ –ø—Å–µ–≤–¥–æ–≥—Ä–∞—Ñ–∏–∫–∏ (0xB0-0xDF –≤ CP866) –ø—Ä–∏–≤–µ–ª–æ –∫ —Ä–∞—Å—Ü–≤–µ—Ç—É –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π —Å –ø—Å–µ–≤–¥–æ–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª–∏: tqdm (Python), htop, top, mc
- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∏: Python (textual, npyscreen), Rust (Ratatui, tui-rs)

---

## Control of Colors in Linux Terminal

::: columns
::: column

* Historical background

  * Based on ASCII `ESC` (0x1B)
  * ANSI escape sequences
  * Originally for teletypes and VT100 terminals

* Structure

  * `ESC [ parameters m`
  * Parameters separated by `;`
  * Ends with `m` (SGR ‚Äî Select Graphic Rendition)

* Common attributes

  * `0` ‚Äî reset
  * `1` ‚Äî bold
  * `4` ‚Äî underline
  * `7` ‚Äî reverse video

:::

::: column

* Basic colors

  * `30‚Äì37` ‚Äî foreground
  * `40‚Äì47` ‚Äî background

* Bright colors

  * `90‚Äì97` ‚Äî foreground
  * `100‚Äì107` ‚Äî background

* Examples

  * `ESC[31m` ‚Äî red text
  * `ESC[1;32m` ‚Äî bold green
  * `ESC[0m` ‚Äî reset

* Modern terminals

  * 256-color mode
  * TrueColor (24-bit RGB)

:::
:::

---

## UTF-32

::: columns
::: column

* Purpose

  * Direct encoding of Unicode code points
  * One code point ‚Üí one storage unit

* Representation

  * Fixed length
  * 32 bits per code unit
  * Value equals Unicode code point

* Properties

  * Constant-time indexing
  * No surrogate pairs
  * No ambiguity

:::

::: column

* Advantages

  * Simplest to process
  * Trivial indexing and slicing
  * Good for algorithms and parsers

* Disadvantages

  * Very high memory usage
  * Poor cache efficiency
  * Rarely used for storage or I/O

* Usage

  * Internal representations
  * Some language runtimes and tools

:::
:::

---

## UTF-16

::: columns
::: column

* Purpose

  * Balance between compactness and simplicity
  * Designed before full Unicode range was known

* Representation

  * Variable length
  * 16 or 32 bits per code point
  * Based on 16-bit code units

* Planes

  * BMP: `U+0000‚ÄìU+FFFF`
  * Supplementary: `U+10000+`

:::

::: column

* Surrogate pairs

  * High: `0xD800‚Äì0xDBFF`
  * Low: `0xDC00‚Äì0xDFFF`
  * Two code units -> one code point

* Properties

  * O(1) indexing by code unit
  * Endianness matters (LE / BE)

* Usage

  * Windows APIs
  * Java, C#, .NET runtimes

:::
:::

---

## UTF-8

::: columns
::: column

* Purpose

  * Universal encoding for byte-oriented systems
  * Safe for ASCII-based software

* Representation

  * Variable length
  * 1‚Äì4 bytes per code point
  * Byte-oriented encoding

* Design principles

  * ASCII compatibility
  * Self-synchronization
  * No endianness

:::

::: column

* Byte structure

  * `0xxxxxxx` ‚Äî 1 byte
  * `110xxxxx` ‚Äî start of 2-byte
  * `1110xxxx` ‚Äî start of 3-byte
  * `11110xxx` ‚Äî start of 4-byte
  * `10xxxxxx` ‚Äî continuation

* Properties

  * Dominant Internet encoding
  * Robust to corruption
  * Natural fit for C and POSIX APIs

:::
:::

---


## Why Only Code Units Are Indexable in O(1)

::: columns
::: column

* **Memory model**

  * Strings are stored as contiguous arrays
  * Indexing is pointer arithmetic
  * Requires fixed-size elements

* **Code units**

  * Fixed size within an encoding
  * UTF-8: 1 byte
  * UTF-16: 2 bytes
  * UTF-32: 4 bytes
  * Enables direct address calculation

* **Language design**

  * C, C++, Java, C#, JavaScript index code units
  * `s[i]` means ‚Äúi-th code unit‚Äù, not ‚Äúi-th symbol‚Äù

:::

::: column

* **Code points**

  * Variable number of code units
  * UTF-8: 1‚Äì4 code units
  * UTF-16: 1 or 2 code units
  * Requires scanning from start -> O(n)

* **Graphemes**

  * Defined by Unicode segmentation rules
  * Can span multiple code points
  * Context-dependent
  * No fixed size -> no random access

* **Conclusion**

  * O(1) indexing is possible **only** for fixed-size units
  * Higher-level ‚Äúcharacters‚Äù require iteration

:::
:::

---



## UTF-8 Encoding Examples

::: columns
::: column

**1-byte (ASCII)**

* `A` = U+0041 ‚Üí `0x41`
* Binary: `01000001`

**2-byte (Latin, Cyrillic)**

* `–π` = U+0439
* Binary: `110_10000 10_111001`
* Bytes: `0xD0 0xB9`

**3-byte (CJK, symbols)**

* `‚Ç¨` = U+20AC
* Binary: `1110_0010 10_000010 10_101100`
* Bytes: `0xE2 0x82 0xAC`

:::

::: column

**4-byte (emoji, rare symbols)**

* `üòÄ` = U+1F600
* Binary: `11110_000 10_011111 10_011000 10_000000`
* Bytes: `0xF0 0x9F 0x98 0x80`

**Encoding formula**

| Range | Bytes | Pattern |
|-------|-------|---------|
| U+0000‚Äì007F | 1 | `0xxxxxxx` |
| U+0080‚Äì07FF | 2 | `110xxxxx 10xxxxxx` |
| U+0800‚ÄìFFFF | 3 | `1110xxxx 10xxxxxx 10xxxxxx` |
| U+10000‚Äì10FFFF | 4 | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` |

:::
:::

---

## Grapheme Clusters ‚Äî What Users See vs What Computers Store

::: columns
::: column

**Problem**

* User sees one "character"
* Computer may store multiple code points
* Indexing by code point breaks visual symbols

**Examples**

| Visual | Code points | Count |
|--------|-------------|-------|
| `√©` | U+0065 U+0301 | 2 |
| `üá´üá∑` | U+1F1EB U+1F1F7 | 2 |
| `üë®‚Äçüë©‚Äçüëß` | U+1F468 U+200D U+1F469 U+200D U+1F467 | 5 |
| `üë©üèΩ‚Äçüî¨` | U+1F469 U+1F3FD U+200D U+1F52C | 4 |

:::

::: column

**Terminology**

* **Code point** ‚Äî Unicode number (e.g., U+0041)
* **Grapheme cluster** ‚Äî user-perceived character
* **ZWJ** (U+200D) ‚Äî Zero Width Joiner, combines emoji

**Implications**

* `len("üë®‚Äçüë©‚Äçüëß")` in Python = 5 (code points)
* Visual length = 1 (grapheme)
* Safe text processing requires grapheme-aware libraries

**Libraries**

* Python: `grapheme`, `regex` with `\X`
* JavaScript: `Intl.Segmenter`
* Rust: `unicode-segmentation`

:::
:::

---

## Unicode Normalization (NFC, NFD)

::: columns
::: column

**Problem**

* Same visual character can have multiple representations
* `√©` = U+00E9 (precomposed) OR U+0065 + U+0301 (decomposed)
* String comparison may fail unexpectedly

**Normalization forms**

| Form | Name | Description |
|------|------|-------------|
| **NFC** | Composed | Combines where possible |
| **NFD** | Decomposed | Separates into base + combining |
| **NFKC** | Compat. composed | + compatibility mappings |
| **NFKD** | Compat. decomposed | + compatibility mappings |

:::

::: column

**Example**

```python
s1 = "caf√©"        # √© = U+00E9
s2 = "cafe\u0301"  # e + combining accent

s1 == s2           # False!
len(s1), len(s2)   # (4, 5)

import unicodedata
n1 = unicodedata.normalize("NFC", s1)
n2 = unicodedata.normalize("NFC", s2)
n1 == n2           # True
```

**Best practice**

* Normalize to NFC on input
* Use NFC for storage and comparison
* NFKC for search (folds ligatures, etc.)

:::
:::

---

## Byte Order Mark (BOM)

::: columns
::: column

**What is BOM?**

* Special Unicode character: U+FEFF
* Placed at file start
* Indicates byte order for UTF-16/32
* Optional "signature" for UTF-8

**BOM bytes**

| Encoding | BOM bytes |
|----------|-----------|
| UTF-8 | `EF BB BF` |
| UTF-16 LE | `FF FE` |
| UTF-16 BE | `FE FF` |
| UTF-32 LE | `FF FE 00 00` |
| UTF-32 BE | `00 00 FE FF` |

:::

::: column

**Problems with BOM**

* UTF-8 BOM breaks many Unix tools
* `#!/usr/bin/python` fails with BOM
* JSON spec forbids BOM
* Concatenating files duplicates BOM

**Handling in Python**

```python
# Read with BOM handling
with open("file.txt", encoding="utf-8-sig") as f:
    text = f.read()

# Write without BOM (recommended)
with open("out.txt", encoding="utf-8") as f:
    f.write(text)
```

**Recommendation**

* Avoid UTF-8 BOM in new files
* Use `utf-8-sig` when reading unknown files

:::
:::

---

## Most Important UTF-8 Symbol Ranges

::: columns
::: column

* Basic Latin

  * U+0000‚ÄìU+007F
  * ASCII compatibility

* Latin-1 Supplement

  * U+0080‚ÄìU+00FF
  * Western European accents

* Cyrillic

  * U+0400‚ÄìU+04FF

* Greek

  * U+0370‚ÄìU+03FF

:::

::: column

* CJK Unified Ideographs

  * U+4E00‚ÄìU+9FFF
  * Chinese, Japanese, Korean

* Emojis

  * U+1F300‚ÄìU+1FAFF
  * Mostly 4-byte UTF-8

* Combining marks

  * U+0300‚ÄìU+036F
  * Diacritics applied to base letters

:::
:::

---

## UCS in Python vs Unicode: Key Difference

::: columns
::: column

* **Unicode**

  * Abstract standard
  * Defines:

    * Code points (`U+0000 ‚Äì U+10FFFF`)
    * Character properties
    * Grapheme rules
  * Independent of storage
  * Not an encoding by itself

* **Unicode encoding**

  * Concrete byte representation
  * Examples: UTF-8, UTF-16, UTF-32
  * Define how code points map to bytes

* **Important**

  * Unicode answers *what symbols exist*
  * Encodings answer *how symbols are stored*

:::

::: column

* **UCS (Universal Character Set)**

  * ISO/IEC 10646
  * Defines fixed-width storage models
  * UCS-2: 2 bytes per code point (obsolete)
  * UCS-4: 4 bytes per code point

* **Python strings**

  * Internally store Unicode code points
  * Representation chosen automatically:

    * 1, 2, or 4 bytes per code point
  * Similar to UCS-4 semantics, but optimized

* **Key difference**

  * UCS = storage model
  * Unicode = abstract character system
  * Python separates *logical Unicode* from *physical storage*

:::
:::

---

## Character Encodings: Standards and Timeline

::: columns
::: column

* Encodings evolve with hardware and needs
* Early standards were regional
* Unicode unified character representation
* Storage and transmission followed later

:::

::: column

| Encoding         | Standard           | Year |
| ---------------- | ------------------ | ---- |
| Morse Code       | ITU                | 1844 |
| Baudot / ITA2    | ITU-T              | 1930 |
| ASCII            | ANSI X3.4          | 1963 |
| ISO-8859-1       | ISO                | 1987 |
| CP866        | IBM / DOS          | 1986 |
| Windows-1251 | Microsoft          | 1995 |
| Unicode          | Unicode Consortium | 1991 |
| UTF-8            | ISO/IEC 10646      | 1993 |
| UTF-16           | ISO/IEC 10646      | 1996 |
| UTF-32           | ISO/IEC 10646      | 1996 |

:::
:::

---

## –ò—Ç–æ–≥–∏ —Ä–∞–∑–¥–µ–ª–∞

* –í –∑–∞–ø–∏—Å–∏ —Å—Ç—Ä–æ–∫–∏ —Å—Ç–æ–∏—Ç —Ä–∞–∑–ª–∏—á–∞—Ç—å –±–∞–π—Ç, –∫–æ–¥–æ–≤—É—é –µ–¥–∏–Ω–∏—Ü—É, –∫–æ–¥–æ–≤—É—é —Ç–æ—á–∫—É –∏ –≥—Ä–∞—Ñ–µ–º—É.
* –°—É—â–µ—Å—Ç–≤—É—é—Ç –∫–æ–¥–∏—Ä–æ–≤–∫–∏ —Å –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π (–∫–æ–¥ –ë–æ–¥–æ, latin-1, ASCII, UTF-32) –∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª–∏–Ω–æ–π –Ω–∞ –æ–¥–Ω—É –∫–æ–¥–æ–≤—É—é —Ç–æ—á–∫—É (UTF-8, UTF-16).
* –î–ª—è –∫–æ–¥–∏—Ä–æ–≤–∫–∏ ASCII –Ω–∏–∂–Ω—è—è —á–∞—Å—Ç—å —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞ (–¥–æ 127) –∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –∞–Ω–≥–ª–∏–π—Å–∫–∏–π –∞–ª—Ñ–∞–≤–∏—Ç, –∑–Ω–∞–∫–∏ –ø—Ä–µ–ø–∏–Ω–∞–Ω–∏—è –∏ —É–ø—Ä–∞–≤–ª—è—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã.
* –í–µ—Ä—Ö–Ω—è—è —á–∞—Å—Ç—å –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è —Ä–µ–≥–∏–æ–Ω–∞–ª—å–Ω—ã–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–º. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –¢–∞–∫–æ–π –ø–æ–¥—Ö–æ–¥ —Å–∏–ª—å–Ω–æ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏–Ω—Ç–µ—Ä–Ω–∞—Ü–∏–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ –∏ —Å–º–µ—à–∏–≤–∞–Ω–∏—è —è–∑—ã–∫–æ–≤.
* Unicode (UTF-8, UTF-16, UTF-32) –ø–æ–∑–≤–æ–ª—è–µ—Ç –∑–∞–¥–∞—Ç—å –ø–æ—á—Ç–∏ –≤—Å–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã, –∑–Ω–∞–∫–∏, —ç–º–æ–¥–∑–∏ –∏ –¥—Ä—É–≥–∏–µ —Å–∏–º–≤–æ–ª—ã. UTF-8 –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –æ—Ç 1 –¥–æ 4 –±–∞–π—Ç –Ω–∞ –∫–æ–¥–æ–≤—É—é —Ç–æ—á–∫—É. –≠—Ç–æ –≤—ã–∑—ã–≤–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã —Å —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π —Å—Ç—Ä–æ–∫ –≤ —è–∑—ã–∫–∞—Ö –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.
* –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –∏ ESC-–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –ø–æ–∑–≤–æ–ª—è—é—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –∫–æ–Ω—Å–æ–ª—å–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∏ –ø—Å–µ–≤–¥–æ–æ–∫–Ω–∞–º–∏. –¢–∞–∫–æ–π —Ç–∏–ø –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –≤—Å—ë –µ—â—ë —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω.

# String in Memory

## ELF executable file (REPEAT)

::: columns
::: column

* ELF Header
  * File metadata (architecture, ABI, entry point)
  * Pointers to PHT and SHT

* Program Header Table (PHT)
  * List of loadable segments
  * File offset ‚Üí virtual address
  * Size, permissions (R / W / X)

* Sections (`.text`, `.rodata`, `.data`, ‚Ä¶)
  * Logical grouping for compiler & linker
  * Mostly irrelevant at runtime

* Section Header Table (SHT)
  * Used by tools (`ld`, `objdump`, `readelf`)
  * Can be removed in stripped binaries

:::

::: column


![](plots/elf_layout.png)

:::
:::

---

## Virtual memory of the process (REPEAT)

::: columns
::: column

* What the OS provides
  * Private **virtual address space**
  * Isolated from other processes

* Memory regions
  * Code / data ‚Äî from ELF segments
  * Heap ‚Äî dynamic allocation (`malloc`)
  * Stack ‚Äî function calls, locals
  * `mmap` ‚Äî shared libs, mapped files

* Protection
  * Per-region permissions (R / W / X)
  * Enforced by memory management unit (MMU)

:::

::: column

![](plots/virtual_memory.png)

:::
:::

---

## String literals and memory (.rodata)

::: columns
::: column

```c
#include <stdio.h>

int main(void) {
    const char *p = "Hello";
    printf("%s\n", p);
    return 0;
}
```

:::

::: column


**String literal `"Hello"`**

* Stored in ELF section `.rodata`
* Mapped into process memory as **read-only**
* May be shared between processes
* Lifetime: whole program execution
* Attempt to modify ‚Üí **undefined behavior**


:::
:::

---

## `"Hello"` vs `{'H','e','l','l','o'}`

::: columns
::: column

```c
char a[] = "Hello";
char b[] = {'H','e','l','l','o'};
```

Memory layout:

```
a: 'H' 'e' 'l' 'l' 'o' '\0'
b: 'H' 'e' 'l' 'l' 'o'
```

:::

::: column


**Key difference**

* `"Hello"` is a string literal

  * includes implicit `'\0'`
* Character list does **not**

  * no terminator
  * not a C-string

**Consequences**

* `a` is a valid C-string
* `b` is a raw character array
* Using `b` as string ‚Üí **undefined behavior**


:::
:::

---

## C strings (null-terminated)

::: columns
::: column

```c
char s[] = "Hello";

printf("%s\n", s);      // OK
printf("%zu\n", strlen(s)); // O(n)
```

Memory layout:

```
'H' 'e' 'l' 'l' 'o' '\0'
```

:::

::: column


**C-string model**

* Sequence of `char`
* Terminated by `'\0'`
* Length is **not stored**

**Complexity**

* Access to character ‚Äî **O(1)**
* `strlen`, `printf`, `strcpy` ‚Äî **O(n)**
  (scan until `'\0'`)

**Risks**

* Missing terminator ‚Üí out-of-bounds read
* Buffer overflow ‚Üí undefined behavior


:::
:::

---

## Pascal strings (length-prefixed)

::: columns
::: column

```pascal
var
  s: string[5];
begin
  s := 'Hello';
  writeln(s);
end;
```

Memory layout:

```
5 'H' 'e' 'l' 'l' 'o'
```

:::

::: column


**Pascal string model**

* First byte stores string length
* Characters follow
* No terminating `'\0'`

**Complexity**

* Length access ‚Äî **O(1)**
* Character access ‚Äî **O(1)**

**Properties**

* Binary-safe (may contain zero bytes)
* Maximum length is fixed
* No scanning, no missing-terminator bugs


:::
:::

---

## Dynamic allocation of a C-string

```c
#include <stdlib.h>
#include <string.h>

int main(void) {
    const char *src = "Hello";   // string literal in .rodata

    size_t len = strlen(src);    // number of bytes before '\0' (O(n))

    char *dst = malloc(len + 1); // allocate bytes on heap (+1 for '\0')

    memcpy(dst, src, len + 1);   // copy all bytes including terminator

    free(dst);                   // release heap memory

    return 0;
}
```

---

## Memory leak via function call (C-strings)

```c
void set_string(char **dst) {
    *dst = malloc(6);             // allocate memory on heap
    memcpy(*dst, "Hello", 6);     // copy "Hello\0"
}

char *s = NULL;
set_string(&s);               // s -> heap ("Hello")
set_string(&s);               // previous pointer overwritten
free(s);                      // only second allocation is freed
```

* Losing the last pointer to heap-allocated string means losing the ability to `free` it.
* unreachable memory cannot be freed ‚Üí **memory leak**

---

## Double free (C-strings)

```c
void destroy(char *s) {
    free(s);          // first free
}

char *s = malloc(6);
memcpy(s, "Hello", 6);

destroy(s);           // memory freed
free(s);              // second free (UB)
```

* The same heap pointer is freed twice
* Heap allocator state becomes corrupted
* Result: crash, memory corruption, or silent bugs

---

## String vulnerability: obvious buffer overflow

::: columns
::: column

```c
void vulnerable(const char *input) {
    char buf[8];
    // no bounds checking
    strcpy(buf, input);
}
```

Stack layout (simplified):

```
buf[8]
saved frame pointer
return address   ‚Üê overwritten
```

:::

::: column

* `strcpy` copies until `'\0'`
* buffer size is not checked
* long input overwrites stack data
* stack control data may be corrupted
* leads to crash or code execution

Any C-string function that ignores buffer size is a potential security vulnerability.

:::
:::

---

## `<string.h>` ‚Äî strings and memory (overview)


::: columns
::: column

\footnotesize
```c
/* string length */
size_t strlen(const char *s);
/* string copy */
char *strcpy(char *dst, const char *src);
char *strncpy(char *dst, const char *src, size_t n);
/* string concatenation */
char *strcat(char *dst, const char *src);
char *strncat(char *dst, const char *src, size_t n);
/* string comparison */
int strcmp(const char *a, const char *b);
int strncmp(const char *a, const char *b, size_t n);
/* string search */
char *strchr(const char *s, int c);
char *strrchr(const char *s, int c);
char *strstr(const char *s, const char *sub);
/* tokenization */
char *strtok(char *s, const char *delim);
/* memory operations */
void *memcpy(void *dst, const void *src, size_t n);
void *memmove(void *dst, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int   memcmp(const void *a, const void *b, size_t n);
void *memchr(const void *s, int c, size_t n);
```

\normalsize
:::

::: column

\footnotesize

**Two families of functions**

* *String functions* ‚Äî work with `'\0'`-terminated data
* *Memory functions* ‚Äî work with raw bytes, length is explicit

**Two variants for most operations**

* unbounded: `strcpy`, `strcat`, `strcmp`
* bounded: `strncpy`, `strncat`, `strncmp`

**Important consequences**

* String functions do **not** know buffer size
* Length is discovered by scanning for `'\0'` (often O(n))
* Memory functions always require explicit size
* `memcpy` vs `memmove`: overlap unsafe vs safe

\normalsize

:::
:::


---

## C-string pitfalls and vulnerabilities

::: columns
::: column

**Memory safety**

* Buffer overflow (stack / heap)
* Off-by-one errors
* Missing `'\0'` terminator
* Use-after-free
* Double free
* Memory leaks

**Lifetime and ownership**

* Unclear ownership rules
* Losing last pointer to allocation
* Freeing memory in wrong scope
* Mixing literals and heap strings

:::

::: column

**Logic and API pitfalls**

* No stored length information
* `strlen` and friends are O(n)
* Unsafe standard functions
  (`strcpy`, `strcat`, `sprintf`)
* Misuse of `strncpy`

**Security and correctness**

* Format string vulnerabilities
* Integer overflow in size calculations
* Encoding confusion (UTF-8 byte length)
* Path truncation and TOCTOU bugs

:::
:::

---

## Python strings: creation and basic operations

::: columns
::: column

```python
s1 = "Hello"
s2 = 'World'
s3 = s1 + " " + s2

print(s3)          # Hello World
print(s3.upper()) # HELLO WORLD
print(s3[0])      # H
print(s3[1:5])    # ello
```

:::

::: column

**String creation**

* Strings are created with single or double quotes
* Resulting object type is `str`
* Strings are sequences (support indexing and slicing)

**Basic operations**

* Concatenation creates a new string
* Indexing and slicing are safe
* No null terminator, no manual memory handling

:::
:::

---

## Python strings: encodings and storage

::: columns
::: column

```python
s = "–ü—Ä–∏–≤–µ—Ç"

print(type(s))        # <class 'str'>
print(len(s))         # 6

b = s.encode("utf-8")
print(b)              # bytes
```

:::

::: column

**Encoding model**

* `str` is a sequence of Unicode code points
* Encoding is not visible at language level
* Internally Python uses UCS-1 / UCS-2 / UCS-4
  (chosen automatically)

**Text vs bytes**

* `str` = text (Unicode)
* `bytes` = raw byte sequence
* Encoding converts text to bytes explicitly

:::
:::

---

## Python strings: immutability

::: columns
::: column

```python
s = "Hello"
s[0] = "h"     # TypeError

t = s.replace("H", "h")

print(s)       # Hello
print(t)       # hello
```

:::

::: column

**Immutability**

* Python strings cannot be modified in place
* Any operation that looks like modification
  creates a new `str` object

**Consequences**

* Strings are safe to share
* Hash value can be cached
* Efficient use as dictionary keys

:::
:::

---

## Python strings: length, hash, interning

::: columns
::: column

```python
s = "hello"

print(len(s))      # O(1)
print(hash(s))     # cached

a = "world"
b = "world"
print(a is b)      # may be True

import sys
c = sys.intern("test")
```

:::

::: column

**Length**

* String length is stored explicitly
* `len(s)` works in O(1)

**Hash**

* Hash value is computed lazily
* Cached inside the string object
* Safe due to immutability

**Interning**

* Some strings are interned automatically
* Explicit interning via `sys.intern`
* Interning is an optimization, not a guarantee

:::
:::

---

## Efficient string concatenation

::: columns
::: column

### Python

```python
s = ""
for x in parts:
    s += x # Inefficient
```

```python
s = "".join(parts) # Efficient
```

* `str` is immutable
* `s += x` creates a new string each time, leads to O(n¬≤) total copying


* `join` computes total length first
* allocates memory once and copies each part exactly once
* overall complexity: O(n)

:::

::: column

### Java

```java
String s = "";
for (String x : parts) {
    s += x; // Inefficient
}
```

```java
StringBuilder sb = new StringBuilder();
for (String x : parts) {
    sb.append(x); // Efficient
}
String s = sb.toString();
```

* `String` is immutable
* `+` creates temporary objects
* compiler cannot optimize loops

* `StringBuilder` is a mutable buffer
* amortized O(1) append one final string allocation

:::
:::

---

## Python strings and memory ‚Äî overview

\footnotesize

::: columns
::: column

```python
# string length
len(s)
# string concatenation
s + t
"".join(iterable)
# comparison
s == t
s < t
# search
s.find(sub)
s.index(sub)
sub in s
# replacement
s.replace(old, new)
# splitting / joining
s.split(sep)
sep.join(parts)
# encoding / decoding
b = s.encode("utf-8")
s = b.decode("utf-8")
```

:::

::: column

**Two distinct types**

* `str` ‚Äî text (Unicode code points)
* `bytes` ‚Äî raw binary data

**Explicit separation**

* text and binary data are different types
* encoding / decoding is always explicit
* prevents accidental mixing of bytes and text


:::
:::

\normalsize

---

## –í—ã–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫: —Å—Ç–µ–∫ vs –∫—É—á–∞

\footnotesize

| –Ø–∑—ã–∫ | –ü—Ä–∏–º–µ—Ä (—Å—Ç–µ–∫ / static) | –ü—Ä–∏–º–µ—Ä (–∫—É—á–∞) |
|----|------------------------|---------------|
| **C** | `char s[16] = "hi";` | `char *s = malloc(16);` |
| **C++** | `char s[] = "hi";` | `std::string s = "hi";` |
| **Rust** (str) | `let s: &str = "hi";` | ‚Äî |
| **Rust** (String) | ‚Äî | `let s = String::from("hi");` |
| **Java (‚â§ 8)** | ‚Äî | `String s = "hi";` |
| **Java (9+)** | ‚Äî | `String s = "hi";` |
| **Go** | ‚Äî | `s := "hi"` |
| **C#** | ‚Äî | `string s = "hi";` |
| **Python** | ‚Äî | `s = "hi"` |
| **JavaScript** | ‚Äî | `let s = "hi";` |
| **Swift** | ‚Äî | `var s = "hi"` |

\normalsize

–í–æ –≤—Å–µ—Ö —è–∑—ã–∫–∞—Ö —Å–æ —Å–±–æ—Ä–∫–æ–π –º—É—Å–æ—Ä–∞ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∑–∞—Å—Ç–∞–≤–∏—Ç—å –æ–±—ä–µ–∫—Ç—ã —è–≤–Ω–æ –≤—ã–¥–µ–ª—è—Ç—å—Å—è –Ω–∞ —Å—Ç–µ–∫–µ.

---

## –ö–∞–∫–∏–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç —è–∑—ã–∫–∏ (—É—Ç–æ—á–Ω—ë–Ω–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞)

\footnotesize

| –Ø–∑—ã–∫ | –¢–∏–ø —Å—Ç—Ä–æ–∫–∏ | –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –º–æ–¥–µ–ª—å | –ö–æ–¥–∏—Ä–æ–≤–∫–∞ | –ë–∞–∑–æ–≤–∞—è –µ–¥–∏–Ω–∏—Ü–∞ |
|----|-----------|------------------|-----------|------------------|
| **C** | `char *` | –º–∞—Å—Å–∏–≤ –±–∞–π—Ç | –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ | –±–∞–π—Ç |
| **C++** | `std::string` | –º–∞—Å—Å–∏–≤ –±–∞–π—Ç | –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ | –±–∞–π—Ç |
| **Java (‚â§ 8)** | `String` | `char[]` | UTF-16 | UTF-16 code unit |
| **Java (9+)** | `String` | `byte[] + coder` | Latin-1 / UTF-16 | code unit |
| **C#** | `string` | `char[]` | UTF-16 | UTF-16 code unit |
| **Python** | `str` | Unicode object | UCS-1/2/4 | code point |
| **Go** | `string` | `(ptr, len)` | UTF-8 (—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ) | –±–∞–π—Ç |
| **Rust (`&str`)** | slice | `(ptr, len)` | UTF-8 (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) | –±–∞–π—Ç |
| **Rust (`String`)** | owning buffer | `Vec<u8>` | UTF-8 (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) | –±–∞–π—Ç |
| **JavaScript** | `string` | UTF-16 | UTF-16 | code unit |
| **Swift** | `String` | Unicode | UTF-8/16/32 (–∞–≤—Ç–æ) | grapheme cluster |
| **PHP** | `string` | –±–∞–π—Ç—ã | –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ | –±–∞–π—Ç |

\normalsize

---

## –°—Ç—Ä–æ–∫–∏: –º—É—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å, —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ, –∏–Ω—Ç–µ—Ä–Ω–∏–Ω–≥

\footnotesize

| –Ø–∑—ã–∫ | –ú—É—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å | –•—Ä–∞–Ω–µ–Ω–∏–µ —Ö–µ—à–∞ | –ò–Ω—Ç–µ—Ä–Ω–∏–Ω–≥ |
|----|---------------------|--------------------------|-----------------|
| **C** | –¥–∞ | –Ω–µ—Ç | –Ω–µ—Ç |
| **C++** | –¥–∞ (`std::string`) | –Ω–µ—Ç | –Ω–µ—Ç |
| **Java** | –Ω–µ—Ç (immutable) | –¥–∞ | –¥–∞ (–ª–∏—Ç–µ—Ä–∞–ª—ã, `intern()`) |
| **C#** | –Ω–µ—Ç (immutable) | –¥–∞ | –¥–∞ (–ª–∏—Ç–µ—Ä–∞–ª—ã, `String.Intern`) |
| **Python** | –Ω–µ—Ç (immutable) | –¥–∞ | —á–∞—Å—Ç–∏—á–Ω–æ (—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è, `sys.intern`) |
| **Go** | –Ω–µ—Ç (immutable) | –Ω–µ—Ç | –Ω–µ—Ç |
| **Rust (`String`)** | –¥–∞ | –Ω–µ—Ç | –Ω–µ—Ç |
| **Rust (`&str`)** | –Ω–µ—Ç | –Ω–µ—Ç | –Ω–µ—Ç |
| **JavaScript** | –Ω–µ—Ç (immutable) | –Ω–µ—Ç | —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–≤–∏–∂–∫–∞ |
| **Swift** | –ª–æ–≥–∏—á–µ—Å–∫–∏ –Ω–µ—Ç (CoW) | –Ω–µ—Ç | —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è |
| **Ruby** | –¥–∞ | —á–∞—Å—Ç–∏—á–Ω–æ (–∏–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç—Å—è) | –Ω–µ—Ç (–∏–Ω—Ç–µ—Ä–Ω—è—Ç—Å—è `Symbol`) |
| **PHP** | –¥–∞ | –Ω–µ—Ç | –Ω–µ—Ç |

\normalsize

---

## Strings: length and access complexity

\footnotesize

| Language | Length stored | Encoding | `len` | n-th byte | n-th code unit | n-th code point |
|--------|---------------|----------|-------|-----------|----------------|-----------------|
| **C** | no | ‚Äî | **O(n)** | O(1) | O(1) | O(n) |
| **C++** (`std::string`) | yes | bytes | O(1) | O(1) | O(1) | O(n) |
| **Java ‚â§8** | yes | UTF-16 | O(1) | O(1) | O(1) | O(n) |
| **Java 9+** | yes | Latin-1 / UTF-16 | O(1) | O(1) | O(1) | O(n) |
| **C#** | yes | UTF-16 | O(1) | O(1) | O(1) | O(n) |
| **Python 3** | yes | flexible | O(1) | O(1) | O(1) | O(1) |
| **Go** | yes | **UTF-8** | O(1) | O(1) | ‚Äî | **O(n)** |
| **Rust** `&str` | yes | **UTF-8** | O(1) | O(1) | ‚Äî | **O(n)** |
| **Rust** `String` | yes | **UTF-8** | O(1) | O(1) | ‚Äî | **O(n)** |
| **JavaScript** | yes | UTF-16 | O(1) | O(1) | O(1) | O(n) |
| **Swift** | yes | Unicode | **O(n)** | O(1) | O(1) | **O(n)** |
| **PHP** | yes | bytes | O(1) | O(1) | O(1) | O(n) |

\normalsize

---

## –ò—Ç–æ–≥–∏ —Ä–∞–∑–¥–µ–ª–∞

* –°—Ç—Ä–æ–∫–∏ —á–∞—Å—Ç–æ —è–≤–ª—è—é—Ç—Å—è —Ä–µ—Å—É—Ä—Å–∞–º–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã. –•—Ä–∞–Ω—è—Ç—Å—è –≤ .rodata —á–∞—Å—Ç–∏ ELF-—Ñ–∞–π–ª–∞
* –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–æ–∫ –≤ C –±—ã–ª–∞ –Ω–∞—Å—Ç–æ–ª—å–∫–æ –ø–ª–æ—Ö–æ–π, —á—Ç–æ –º–Ω–æ–≥–∏–µ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–∏ —Ä–æ–¥–∏–ª–∏—Å—å –≤ –ø–æ–ø—ã—Ç–∫–µ —ç—Ç–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å
* –°-—Å—Ç—Ä–æ–∫–∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—Ç—Å—è –Ω—É–ª—ë–º, Pascal-—Å—Ç—Ä–æ–∫–∏ —è–≤–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç –¥–ª–∏–Ω—É —Å—Ç—Ä–æ–∫–∏
* –í Python –≤—Å–µ —Å—Ç—Ä–æ–∫–∏ —Ö—Ä–∞–Ω—è—Ç—Å—è –≤ UCS-1/2/4 —Ñ–æ—Ä–º–∞—Ç–µ, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–π –∫–æ–¥–∏—Ä–æ–≤–∫–∏. –£ —ç—Ç–∏—Ö –∫–æ–¥–∏—Ä–æ–≤–æ–∫ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Ç–æ—á–∫–∏ –∫–æ–¥–∏—Ä–æ–≤–∞—è, —á—Ç–æ –¥–∞—ë—Ç –¥–æ—Å—Ç—É–ø –∫ n-–π —Ç–æ—á–∫–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞ O(1).
* –í Java, JavaScript, Rust, C# –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–æ–¥–∏—Ä–æ–≤–∫–∏ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª–∏–Ω–æ–π UTF-8/16, –ø–æ—ç—Ç–æ–º—É –¥–æ—Å—Ç—É–ø –∫ n-–π —Ç–æ—á–∫–µ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞ O(n).
* –Ø–∑—ã–∫–∏ —Å–æ–¥–µ—Ä–∂–∞—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –∫–æ–Ω–∫–∞—Ç–µ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫, —ç—Ç–æ –∞–Ω–∞–ª–æ–≥–∏ StringBuilder –∏–∑ Java, –∏–ª–∏ .join([]) –∫–∞–∫ –≤ Python
* –í –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —è–∑—ã–∫–æ–≤ —Å—Ç—Ä–æ–∫–∏ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏–ª–∏ –æ–±—ä–µ–∫—Ç—ã. –û–Ω–∏ —è–≤–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç –∑–∞–ø–∏—Å—å —Å–≤–æ–µ–π –¥–ª–∏–Ω—ã, —Ö–µ—à. –°—Ç—Ä–æ–∫–∏ –º–æ–≥—É—Ç –∏–Ω—Ç–µ—Ä–Ω–∏—Ä–æ–≤–∞—Ç—å—Å—è.

# Regular Expression

## Wildcards (glob) vs Regular Expressions

::: columns
::: column

### Wildcards (glob)
- Filename pattern matching
- Implemented by shell / filesystem libraries
- In shell: expanded **before** program execution
- In libraries: evaluated at runtime (`glob.glob`, `Path.glob`)
- Operates on paths
- Limited expressive power
- No groups or alternation
- Linear-time matching

:::

::: column

### Regular expressions
- Pattern matching over strings
- Implemented by programs / libraries
- Evaluated **during** program execution
- Operate on text streams
- High expressive power
- Groups, alternation, repetition
- DFA / NFA / backtracking engines

:::
:::

---

### Glob syntax

| Pattern | Meaning | Example |
|--------|---------|---------|
| `*` | any string (incl. empty) | `*.txt` |
| `?` | exactly one character | `file_?.dat` |
| `[abc]` | one of listed characters | `img_[abc].png` |
| `[a-z]` | character range | `data_[0-9].csv` |
| `[^a-z]` | negation | `[^._]*` |
| `**` | recursive match | `src/**/*.py` |

- `/` is not matched by `*` or `?`
- `**` is shell- and library-dependent

---

## Wildcards (glob) ‚Äî Python Example

**Scenario:** concatenate all log files from a directory

```python
from pathlib import Path

log_dir = Path("logs")
output = Path("all_logs.txt")

with output.open("w") as out:
    for log_file in sorted(log_dir.glob("*.log")):
        out.write(f"\n=== {log_file.name} ===\n")
        out.write(log_file.read_text())
```

---

## Wildcards (glob) ‚Äî Bash Usage Examples

\footnotesize

```bash
ls *.txt # List all text files

rm *.tmp *.bak # Remove temporary files

gcc src/*.c -o app # Compile all C sources

tar -czf logs.tar.gz logs/2025-*.log # Archive logs by date

grep "ERROR" /var/log/app/app_*.log # Search errors in rotated logs

cp images/*.{png,jpg} backup/ # Copy all images

wc -l data_??.csv # Count lines in CSV files

ls src/**/test_*.py # Find test files recursively (bash ‚â• 4)

ls [!.]* # Exclude hidden files
```

\normalsize

---

## Wildcards (glob) ‚Äî Usage in Programming Languages

| Language | Import / Tool | Example usage |
|---------|---------------|---------------|
| Python | `import glob` | `glob.glob("*.txt")` |
| Python | `from pathlib import Path` | `Path(".").glob("*.py")` |
| Bash | shell builtin | `ls *.txt` |
| Make | implicit glob | `SRC = *.c` |
| C | `<glob.h>` | `glob("*.log", 0, NULL, &g)` |
| C++ | `<filesystem>` | `for (auto& p : fs::directory_iterator("."))` |
| C# | `System.IO` | `Directory.GetFiles(".", "*.txt")` |
| Java | `java.nio.file` | `Files.newDirectoryStream(p, "*.txt")` |
| JavaScript | `glob` (npm) | `glob("**/*.js", cb)` |
| Haskell | `System.FilePath.Glob` | `glob "*.hs"` |
| Rust | `glob` crate | `glob("**/*.rs")?` |
| Go | `path/filepath` | `filepath.Glob("*.md")` |

---

## Regular Expressions ‚Äî Syntax Overview

::: columns
::: column

### Basic syntax

| Construct | Meaning | Example |
|----------|---------|---------|
| `a` | literal character | `cat` |
| `.` | any character | `c.t` |
| `*` | 0 or more | `a*` |
| `+` | 1 or more | `a+` |
| `?` | 0 or 1 | `colou?r` |
| `{n}` | exactly *n* | `\d{4}` |
| `{n,m}` | from *n* to *m* | `\w{2,5}` |
| `[]` | character class | `[A-Z_]` |
| `[^]` | negated class | `[^0-9]` |
| `^` | start of string | `^https?` |
| `$` | end of string | `\.txt$` |

:::

::: column

### Groups and composition

| Construct | Meaning | Example |
|----------|---------|---------|
| `(re)` | capturing group | `(ab)+` |
| `(?:re)` | non-capturing group | `(?:ab)+` |
| `|` | alternation | `cat|dog` |
| `{n,m}` | group repetition | `(ab){2,4}` |
| nested `()` | composition | `(a(bc))*` |
| `^‚Ä¶$` | full match | `^(ab)+$` |
| precedence | `* + ?` > concat > `|` | `ab|cd*` |

:::
:::

---

## Regular Expressions ‚Äî Example, Groups (Python)

```python
import re

text = "user:alice id:42"

m = re.search(r"user:(\w+)\s+id:(\d+)", text)

m.group(0)   # full match
m.group(1)   # 'alice'
m.group(2)   # '42'
m.groups()   # ('alice', '42')
```

* groups define submatches
* alternation applies to whole group

---

## Python `re` Module ‚Äî Overview

::: columns
::: column

### Main functions

\footnotesize

| Function | Purpose | Notes |
|---------|---------|-------|
| `re.match()` | match at start | implicit `^` |
| `re.search()` | find first match | most common |
| `re.findall()` | find all matches | returns list |
| `re.finditer()` | match iterator | memory-efficient |
| `re.fullmatch()` | full string match | implicit `^...$` |
| `re.split()` | split string | regex delimiter |
| `re.sub()` | replace matches | supports groups |
| `re.compile()` | compile pattern | reuse + flags |

\normalsize

:::

::: column

### Flags and notes

**Flags**
- `re.IGNORECASE` / `re.I`
- `re.MULTILINE` / `re.M`
- `re.DOTALL` / `re.S`
- `re.VERBOSE` / `re.X`

**Engine**
- backtracking NFA
- possible exponential behavior

**Practice**
- prefer raw strings: `r"..."`

:::
:::

---

## Regular Expressions ‚Äî Basic Syntax (Python)

```python
import re

text = "Error 404 at line 23"

re.search(r"\d+", text)          # match number
# <re.Match object; span=(6, 9), match='404'>

re.findall(r"[A-Z][a-z]+", text) # words starting with capital
# ['Error']

re.match(r"Error", text)         # match at start
# <re.Match object; span=(0, 5), match='Error'>

re.fullmatch(r".*\d{2}", text)   # full string match
# <re.Match object; span=(0, 20), match='Error 404 at line 23'>
```
---

## Regular Expressions ‚Äî Usage in Programming Languages

**Example pattern:** match a sequence of digits (`[0-9]+`)

| Language | Import / Tool | Example usage |
|---------|---------------|---------------|
| Python | `import re` | `re.search(r"[0-9]+", text)` |
| Bash | `grep -E` | `grep -E "[0-9]+" file` |
| Bash | `sed` | `sed -n '/[0-9]+/p' file` |
| C | `<regex.h>` | `regexec(&re, str, 0, NULL, 0)` |
| C++ | `<regex>` | `std::regex_search(s, std::regex("[0-9]+"))` |
| C# | `System.Text.RegularExpressions` | `Regex.Match(s, "[0-9]+")` |
| Java | `java.util.regex` | `Pattern.compile("[0-9]+").matcher(s)` |
| JavaScript | built-in | `text.match(/[0-9]+/)` |
| Rust | `regex` crate | `Regex::new("[0-9]+")?.is_match(text)` |
| Go | `regexp` | `regexp.MatchString("[0-9]+", s)` |
| Haskell | `regex-tdfa` | `text =~ "[0-9]+"` |

- same logical pattern across languages
- syntax and API differ
- engine behavior may differ

---

## `sed` ‚Äî Stream Editor

::: columns
::: column

### Theory and model

- Line-oriented stream editor
- Processes input sequentially
- Regex-driven commands
- No global memory
- Designed for text transformation
- Typical operations: substitute, delete, print

:::

::: column

### Examples

```bash
# Substitute numbers
sed 's/[0-9]\+/NUM/g' file.txt
```

```bash
# Print matching lines
sed -n '/ERROR/p' app.log
```

```bash
# Delete comments
sed '/^#/d' config.conf
```

```bash
# In-place edit
sed -i 's/foo/bar/g' *.txt
```

:::
:::

---

## `awk` ‚Äî Pattern‚ÄìAction Language

::: columns
::: column

### Theory and model

* Line-based processing language
* Regex as conditions
* Automatic field splitting
* Variables and expressions
* Implicit loop over lines
* Small programs, not just filters

:::

::: column

### Examples

```bash
# Print selected fields
awk '{print $1, $3}' data.txt
```

```bash
# Filter by regex
awk '/ERROR/ {print}' app.log
```

```bash
# Simple condition
awk '$3 > 100 {print $1}' table.txt
```

```bash
# Custom separator
awk -F: '{print $1}' /etc/passwd
```

:::
:::

---

## `awk` + `sed` ‚Äî Combined Usage Example

**Process application logs:** extract error records and anonymize numeric values

```bash
awk '/ERROR/ {print $2, $0}' app.log | sed 's/[0-9]\+/NUM/g'
```

::: columns
::: column

### Explanation

* `awk '/ERROR/ {print $2, $0}'`

  * selects only lines containing `ERROR`
  * prints second field (e.g. module name)
  * keeps the full original line

* `sed 's/[0-9]\+/NUM/g'`

  * replaces all numbers
  * removes IDs, counters, timestamps

:::
::: column

### Example

Input:

```
2025-01-30 ERROR auth failed after 3 attempts
```

Output:

```
auth 2025-01-30 ERROR auth failed after NUM attempts
```

* `awk` ‚Üí filtering and restructuring
* `sed` ‚Üí text normalization

:::
:::

---

## Regex Engines: DFA vs NFA vs Backtracking

::: columns
::: column

**DFA (Deterministic Finite Automaton)**

* One state at a time
* Linear time guarantee: O(n)
* No backtracking
* Limited features (no backreferences)
* Used in: `grep`, `awk`, RE2 (Google)

**NFA (Non-deterministic Finite Automaton)**

* Multiple states simultaneously
* Can simulate DFA behavior
* Foundation for most engines

:::

::: column

**Backtracking NFA**

* Tries paths one by one
* Backtracks on failure
* Supports full regex features
* Worst case: exponential O(2^n)
* Used in: Python, Perl, Java, JavaScript

**Thompson NFA**

* Simulates all paths in parallel
* Linear time O(n)
* Used in: Go `regexp`, Rust `regex`

:::
:::

---

## Catastrophic Backtracking (ReDoS)

::: columns
::: column

**Problem**

* Some patterns cause exponential matching time
* Attacker sends malicious input
* Server hangs ‚Üí Denial of Service

**Dangerous patterns**

```
(a+)+$      # nested quantifiers
(a|aa)+$    # overlapping alternatives
(.*a){10}   # repeated greedy match
```

**Example attack**

```python
import re
# This hangs!
re.match(r"(a+)+$", "a" * 30 + "!")
```

:::

::: column

**Why it happens**

* Pattern: `(a+)+$`
* Input: `aaaaaaaaaa!`
* Engine tries all ways to split `a`s
* 2^n combinations before failing

**Mitigations**

* Use linear-time engines (RE2, Rust regex)
* Avoid nested quantifiers
* Add timeouts
* Use atomic groups `(?>...)`
* Validate regex complexity

**Safe alternatives**

* Python: `google-re2` package
* JavaScript: use `safe-regex` linter
* Rust: `regex` crate (Thompson NFA)

:::
:::

---

## Lookahead and Lookbehind Assertions

::: columns
::: column

**Lookahead**

* Match only if followed by pattern
* Does not consume characters

| Syntax | Name | Example |
|--------|------|---------|
| `(?=...)` | Positive | `\d+(?=‚Ç¨)` ‚Üí digits before ‚Ç¨ |
| `(?!...)` | Negative | `foo(?!bar)` ‚Üí foo not followed by bar |

**Example**

```python
import re
text = "100‚Ç¨ 200$ 50‚Ç¨"
re.findall(r"\d+(?=‚Ç¨)", text)
# ['100', '50']
```

:::

::: column

**Lookbehind**

* Match only if preceded by pattern
* Does not consume characters

| Syntax | Name | Example |
|--------|------|---------|
| `(?<=...)` | Positive | `(?<=\$)\d+` ‚Üí digits after $ |
| `(?<!...)` | Negative | `(?<!un)known` ‚Üí known not after un |

**Example**

```python
text = "$100 ‚Ç¨200 $50"
re.findall(r"(?<=\$)\d+", text)
# ['100', '50']
```

**Limitation**

* Lookbehind must have fixed width in Python
* Variable-width: use `regex` module

:::
:::

---

## Named Groups and Backreferences

::: columns
::: column

**Named groups**

* Give meaningful names to captures
* Improve readability

```python
import re

pattern = r"(?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})"
text = "Date: 2025-01-30"

m = re.search(pattern, text)
m.group("year")   # '2025'
m.group("month")  # '01'
m.group("day")    # '30'
m.groupdict()
# {'year': '2025', 'month': '01', 'day': '30'}
```

:::

::: column

**Backreferences**

* Match same text as earlier group
* Useful for finding duplicates

```python
# Find repeated words
pattern = r"\b(\w+)\s+\1\b"
text = "the the quick brown fox"
re.search(pattern, text).group()
# 'the the'
```

**Named backreference**

```python
# Match opening and closing tags
pattern = r"<(?P<tag>\w+)>.*?</(?P=tag)>"
text = "<div>content</div>"
re.search(pattern, text).group()
# '<div>content</div>'
```

:::
:::

---

## –ò—Ç–æ–≥–∏ —Ä–∞–∑–¥–µ–ª–∞

* **Glob** (wildcards) ‚Äî –º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–æ —Å–ø–∏—Å–∫–∞–º–∏ —Ñ–∞–π–ª–æ–≤. **Regular Expression** ‚Äî –º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç–µ–∫—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏. –û–±–∞ –º–µ—Ö–∞–Ω–∏–∑–º–∞ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è –≤ –∫–æ–Ω—Å–æ–ª–∏ –∏ –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —è–∑—ã–∫–æ–≤ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è.
* **Python `re`** ‚Äî —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –º–æ–¥—É–ª—å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ä–µ–≥—É–ª—è—Ä–Ω—ã–º–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏. –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏: `search`, `match`, `findall`, `sub`, `split`, `compile`.
* **sed** ‚Äî –ø–æ—Ç–æ–∫–æ–≤—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä –¥–ª—è –ø–æ—Å—Ç—Ä–æ—á–Ω—ã—Ö –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π. **awk** ‚Äî —è–∑—ã–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö —Å regex –¥–ª—è —É—Å–ª–æ–≤–∏–π –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º —Ä–∞–∑–±–∏–µ–Ω–∏–µ–º –Ω–∞ –ø–æ–ª—è.
* –°—É—â–µ—Å—Ç–≤—É–µ—Ç –¥–≤–∞ –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ç–∏–ø–∞ regex-–¥–≤–∏–∂–∫–æ–≤: **DFA** (–ª–∏–Ω–µ–π–Ω–æ–µ –≤—Ä–µ–º—è, –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏) –∏ **backtracking NFA** (—ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ, –ø–æ–ª–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å).
* **Catastrophic backtracking** (ReDoS) ‚Äî —É—è–∑–≤–∏–º–æ—Å—Ç—å, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–π –∑–ª–æ–Ω–∞–º–µ—Ä–µ–Ω–Ω—ã–π –≤–≤–æ–¥ –≤—ã–∑—ã–≤–∞–µ—Ç –∑–∞–≤–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã. –ò–∑–±–µ–≥–∞–π—Ç–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –∫–≤–∞–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤ –∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –¥–≤–∏–∂–∫–∏ (RE2, Rust regex).
* **Lookahead/lookbehind** –ø–æ–∑–≤–æ–ª—è—é—Ç –ø—Ä–æ–≤–µ—Ä—è—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –±–µ–∑ –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤. **Named groups** —É–ª—É—á—à–∞—é—Ç —á–∏—Ç–∞–µ–º–æ—Å—Ç—å —Å–ª–æ–∂–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤.
