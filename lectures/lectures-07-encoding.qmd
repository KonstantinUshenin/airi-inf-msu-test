---
title: "Informatics. Basics of Software Development"
subtitle: "Lecture 7 — Text data [EARLY DRAFT]"
author: "Konstantin Ushenin"
date: "2026"
---

# Encoding

---

## Binary-Coded Decimal (BCD) — 1950s

::: columns
::: {.column width="60%"}

- Idea
  - Decimal digits encoded separately
  - One digit → one 4-bit nibble
  - No positional binary value across digits

- Encoding rules
  - `0–9` → valid
  - `1010–1111` → invalid / reserved

:::

::: {.column width="40%"}

| Decimal | BCD (binary) | Hex |
|--------:|--------------|-----|
| 0 | 0000 | 0x0 |
| 1 | 0001 | 0x1 |
| 2 | 0010 | 0x2 |
| 3 | 0011 | 0x3 |
| 4 | 0100 | 0x4 |
| 5 | 0101 | 0x5 |
| 6 | 0110 | 0x6 |
| 7 | 0111 | 0x7 |
| 8 | 1000 | 0x8 |
| 9 | 1001 | 0x9 |

:::
:::

---

## Morse Code — 1830s–1840s

::: columns
::: {.column width="60%"}

- Type
  - Variable-length code
  - Time-based (dots and dashes)
  - Not binary in storage sense

- Encoding
  - Short signals for frequent letters
  - Long signals for rare letters
  - Explicit symbol boundaries (pauses)

- Properties
  - Human-decodable
  - No fixed symbol width
  - Optimized for manual transmission

- Usage
  - Telegraphy
  - Radio communication
  - Emergency signaling

:::

::: {.column width="40%"}

![](images/International_Morse_Code.png)

:::
:::

---

## ITA2 / Baudot–Murray Code — 1930s

::: columns
::: {.column width="60%"}

- Type
  - Fixed-length binary code
  - 5 bits → 32 code points

- Control symbols
  - LTRS / FIGS — mode shift control codes
  - CR (Carriage Return) — move to line start
  - LF (Line Feed) — move to next line

- Decoding
  - Context-dependent
  - Same bit pattern → different symbol
  - Mode persists until next shift

:::

::: {.column width="40%"}

![](images/Ita2.png)

:::
:::

---


## What types of encodings exist?

- **Number of bits per symbol**: 4, 5, 7, 8, 16, …
  - Examples: BCD (4), Baudot (5), ASCII (7), Latin-1 (8), UTF-16 (16)

- **Fixed-length vs variable-length**
  - Fixed-length: BCD, Baudot, ASCII
  - Variable-length: Morse code, UTF-8

- **Control symbols**
  - Explicit control codes: Baudot (LTRS / FIGS), ASCII (CR, LF, ESC)
  - Implicit control via structure: Morse code (pauses)
  
---

## American Standard Code for Information Interchange (ASCII) — 1963

![](images/ASCII_Code_Chart.png)

---

## ASCII — 1963

::: columns
::: column

- Control characters
  - `0–31`, `127`
  - Non-printing (`CR`, `LF`, `ESC`)

- Letters
  - `A–Z`: `65–90`
  - `a–z`: `97–122`

**Notes**

- Character ranges are non-contiguous
- Uppercase and lowercase letters have
  - Fixed offset (`+32`)
  - Equal distance in the code table

:::

::: column

- Punctuation ranges

  - `33–47`: `! " # $ % & ' ( ) * + , - . /`
  - `58–64`: `: ; < = > ? @`
  - `91–96`: `[ \ ] ^ _ \``
  - `123–126`: `{ | } ~`

:::
:::

---

## ASCII Control Characters (Key Ones)

::: columns
::: column

BS (Backspace, 0x08)

 - Moves cursor one position left
 - Overwrites previous character
 - Used on teletypes for character composition

CR (Carriage Return, 0x0D)

 - Move cursor to start of line

LF (Line Feed, 0x0A)

 - Move cursor to next line

ESC (Escape, 0x1B)

 - Starts control sequences
 - Basis for ANSI terminal commands

DEL (Delete, 0x7F)

 - Erase character (historical)

:::

::: column

Diacritic composition using BS

- `a BS ' → á`
- `a BS \ → à`
- `a BS ^ → â`
- `a BS " → ä`
- `o BS / → ø`
- `c BS , → ç`
- `n BS ~ → ñ`

Neutral / no-op cases

- `a BS a → a`
- `a BS _ → a`

Idea

- Diacritics were created by overprinting
- No dedicated accented characters in ASCII

:::
:::

---

## Encoding (CP866 and Windows-1251)

::: columns
::: column

![](images/CP866.png)

:::

::: column

![](images/Windows-1251.png)

:::
:::

- Симоволы от 0x00 до 0x7F - ASCII и обычно универсальны.  0x80-0xFF - задавалась национальной частью таблицы кодировки
- Кодировок существует несколько сотен. Разница в кодировках предложенных даже в одной компании могла быть критической
- Отображение документов и Интернет страниц оставалось непредсказуемым

---

## Terminal User Interface

::: columns
::: column

![](images/mc.png)

:::

::: column

![](images/htop.png)

:::
:::

- Появление символов 0xOB-0xFD привело к расцвету приложений с псевдоинтерфейсом
- Современные представители: tqdm (Python), htop, top, mc
- Современные фреймворки: Python (textual, npyscreen), Rust (Ratatui, tui-rs)

---

# String in Memory

---

## ELF executable file (REPEAT)

::: columns
::: column


:::

::: column


![](plots/elf_layout.png)

:::
:::

---

## Virtual memory of the process (REPEAT)

::: columns
::: column


:::

::: column

![](plots/virtual_memory.png)

:::
:::

---

## String literals and memory (.rodata)

::: columns
::: column

```c
#include <stdio.h>

int main(void) {
    const char *p = "Hello";
    printf("%s\n", p);
    return 0;
}
````

:::

::: column


**String literal `"Hello"`**

* Stored in ELF section `.rodata`
* Mapped into process memory as **read-only**
* May be shared between processes
* Lifetime: whole program execution
* Attempt to modify → **undefined behavior**


:::
:::

---

## `"Hello"` vs `{'H','e','l','l','o'}`

::: columns
::: column

```c
char a[] = "Hello";
char b[] = {'H','e','l','l','o'};
```

Memory layout:

```
a: 'H' 'e' 'l' 'l' 'o' '\0'
b: 'H' 'e' 'l' 'l' 'o'
```

:::

::: column


**Key difference**

* `"Hello"` is a string literal

  * includes implicit `'\0'`
* Character list does **not**

  * no terminator
  * not a C-string

**Consequences**

* `a` is a valid C-string
* `b` is a raw character array
* Using `b` as string → **undefined behavior**


:::
:::

---

## C strings (null-terminated)

::: columns
::: column

```c
char s[] = "Hello";

printf("%s\n", s);      // OK
printf("%zu\n", strlen(s)); // O(n)
```

Memory layout:

```
'H' 'e' 'l' 'l' 'o' '\0'
```

:::

::: column


**C-string model**

* Sequence of `char`
* Terminated by `'\0'`
* Length is **not stored**

**Complexity**

* Access to character — **O(1)**
* `strlen`, `printf`, `strcpy` — **O(n)**
  (scan until `'\0'`)

**Risks**

* Missing terminator → out-of-bounds read
* Buffer overflow → undefined behavior


:::
:::

---

## Pascal strings (length-prefixed)

::: columns
::: column

```pascal
var
  s: string[5];
begin
  s := 'Hello';
  writeln(s);
end;
```

Memory layout:

```
5 'H' 'e' 'l' 'l' 'o'
```

:::

::: column


**Pascal string model**

* First byte stores string length
* Characters follow
* No terminating `'\0'`

**Complexity**

* Length access — **O(1)**
* Character access — **O(1)**

**Properties**

* Binary-safe (may contain zero bytes)
* Maximum length is fixed
* No scanning, no missing-terminator bugs


:::
:::

---

## Dynamic allocation of a C-string

```c
#include <stdlib.h>
#include <string.h>

int main(void) {
    const char *src = "Hello";   // string literal in .rodata

    size_t len = strlen(src);    // number of bytes before '\0' (O(n))

    char *dst = malloc(len + 1); // allocate bytes on heap (+1 for '\0')

    memcpy(dst, src, len + 1);   // copy all bytes including terminator

    free(dst);                   // release heap memory

    return 0;
}
```

---

## Memory leak via function call (C-strings)

```c
void set_string(char **dst) {
    *dst = malloc(6);             // allocate memory on heap
    memcpy(*dst, "Hello", 6);     // copy "Hello\0"
}

char *s = NULL;
set_string(&s);               // s -> heap ("Hello")
set_string(&s);               // previous pointer overwritten
free(s);                      // only second allocation is freed
}
```

* Losing the last pointer to heap-allocated string means losing the ability to `free` it.
* unreachable memory cannot be freed → **memory leak**

---

## Double free (C-strings)

```c
void destroy(char *s) {
    free(s);          // first free
}

char *s = malloc(6);
memcpy(s, "Hello", 6);

destroy(s);           // memory freed
free(s);              // second free (UB)
````

* The same heap pointer is freed twice
* Heap allocator state becomes corrupted
* Result: crash, memory corruption, or silent bugs

---

## String vulnerability: obvious buffer overflow

::: columns
::: column

```c
void vulnerable(const char *input) {
    char buf[8];
    // no bounds checking
    strcpy(buf, input);
}
```

Stack layout (simplified):

```
buf[8]
saved frame pointer
return address   ← overwritten
```

:::

::: column

* `strcpy` copies until `'\0'`
* buffer size is not checked
* long input overwrites stack data
* stack control data may be corrupted
* leads to crash or code execution

Any C-string function that ignores buffer size is a potential security vulnerability.

:::
:::

---

## String vulnerability: non-obvious overflow

::: columns
::: column

```c
void subtle(const char *a, const char *b) {
    char buf[16] = "user: ";
    // looks safe
    strcat(buf, a);
    // overflow depends on data
    strcat(buf, b);
}
```

Comment:

```
"user: " + a + b  > 16 bytes → overflow
```

:::

::: column

Why this is dangerous:

* `buf` already contains data
* `strcat` scans for `'\0'` (**O(n)**)
* remaining capacity is unknown
* overflow depends on **combined lengths**
* often missed during code review

Seemingly safe string code can become vulnerable when multiple operations share the same buffer.

:::
:::

---



## `<string.h>` — C-string functions

\footnotesize

::: columns
::: column

```c
size_t strlen(const char *s);
````

* Length of C-string (bytes before `'\0'`)
* Requires scanning the string (O(n))

```c
char *strcpy(char *dst, const char *src);
char *strncpy(char *dst, const char *src, size_t n);
```

* Copy strings
* No bounds checking
* `strncpy` may not add `'\0'`

```c
char *strcat(char *dst, const char *src);
char *strncat(char *dst, const char *src, size_t n);
```

* Append strings
* Destination must already be a valid C-string
* Risk of overflow if buffer is too small

:::

::: column

```c
int strcmp(const char *a, const char *b);
int strncmp(const char *a, const char *b, size_t n);
```

* Lexicographic comparison
* Stops at first difference or `'\0'`

```c
char *strchr(const char *s, int c);
char *strrchr(const char *s, int c);
char *strstr(const char *s, const char *sub);
```

* Search for character or substring
* Return pointer into original string

```c
char *strtok(char *s, const char *delim);
```

* Tokenizes string in-place
* Uses hidden global state
* Not thread-safe

:::
:::

\normalsize

---

## `<string.h>` — memory functions

\footnotesize

::: columns
::: column

```c
void *memcpy(void *dst, const void *src, size_t n);
```

* Copy raw bytes
* Undefined behavior if memory overlaps

```c
void *memmove(void *dst, const void *src, size_t n);
```

* Copy raw bytes
* Safe for overlapping regions

```c
void *memset(void *s, int c, size_t n);
```

* Fill memory with a byte value
* Often used to zero memory

:::

::: column

```c
int memcmp(const void *a, const void *b, size_t n);
```

* Compare memory byte by byte
* Does not stop at `'\0'`

```c
void *memchr(const void *s, int c, size_t n);
```

* Search for a byte in memory
* Works on arbitrary binary data

**General properties**

* Functions do not know buffer sizes
* No automatic bounds checking
* Operate on bytes, not characters
* Correct usage is responsibility of programmer

:::
:::

\normalsize

---

## C-string pitfalls and vulnerabilities

::: columns
::: column

**Memory safety**

* Buffer overflow (stack / heap)
* Off-by-one errors
* Missing `'\0'` terminator
* Use-after-free
* Double free
* Memory leaks

**Lifetime and ownership**

* Unclear ownership rules
* Losing last pointer to allocation
* Freeing memory in wrong scope
* Mixing literals and heap strings

:::

::: column

**Logic and API pitfalls**

* No stored length information
* `strlen` and friends are O(n)
* Unsafe standard functions
  (`strcpy`, `strcat`, `sprintf`)
* Misuse of `strncpy`

**Security and correctness**

* Format string vulnerabilities
* Integer overflow in size calculations
* Encoding confusion (UTF-8 byte length)
* Path truncation and TOCTOU bugs

:::
:::

---

# Regular Expression

---

## Wildcards (glob) vs Regular Expressions

::: columns
::: column

### Wildcards (glob)
- Filename pattern matching
- Implemented by shell / filesystem libraries
- Expanded **before** program execution
- Operates on paths
- Limited expressive power
- No groups or alternation
- Linear-time matching

:::

::: column

### Regular expressions
- Pattern matching over strings
- Implemented by programs / libraries
- Evaluated **during** program execution
- Operate on text streams
- High expressive power
- Groups, alternation, repetition
- DFA / NFA / backtracking engines

:::
:::

---

### Glob syntax

| Pattern | Meaning | Example |
|--------|---------|---------|
| `*` | any string (incl. empty) | `*.txt` |
| `?` | exactly one character | `file_?.dat` |
| `[abc]` | one of listed characters | `img_[abc].png` |
| `[a-z]` | character range | `data_[0-9].csv` |
| `[^a-z]` | negation | `[^._]*` |
| `**` | recursive match | `src/**/*.py` |

- `/` is not matched by `*` or `?`
- `**` is shell- and library-dependent

---

## Wildcards (glob) — Python Example

**Scenario:** concatenate all log files from a directory

```python
from pathlib import Path

log_dir = Path("logs")
output = Path("all_logs.txt")

with output.open("w") as out:
    for log_file in sorted(log_dir.glob("*.log")):
        out.write(f"\n=== {log_file.name} ===\n")
        out.write(log_file.read_text())
```

---

## Wildcards (glob) — Bash Usage Examples

\footnotesize

```bash
ls *.txt # List all text files

rm *.tmp *.bak # Remove temporary files

gcc src/*.c -o app # Compile all C sources

tar -czf logs.tar.gz logs/2025-*.log # Archive logs by date

grep "ERROR" /var/log/app/app_*.log # Search errors in rotated logs

cp images/*.{png,jpg} backup/ # Copy all images

wc -l data_??.csv # Count lines in CSV files

ls src/**/test_*.py # Find test files recursively (bash ≥ 4)

ls [!.]* # Exclude hidden files
```

\normalsize

---

## Wildcards (glob) — Usage in Programming Languages

| Language | Import / Tool | Example usage |
|---------|---------------|---------------|
| Python | `import glob` | `glob.glob("*.txt")` |
| Python | `from pathlib import Path` | `Path(".").glob("*.py")` |
| Bash | shell builtin | `ls *.txt` |
| Make | implicit glob | `SRC = *.c` |
| C | `<glob.h>` | `glob("*.log", 0, NULL, &g)` |
| C++ | `<filesystem>` | `for (auto& p : fs::directory_iterator("."))` |
| C# | `System.IO` | `Directory.GetFiles(".", "*.txt")` |
| Java | `java.nio.file` | `Files.newDirectoryStream(p, "*.txt")` |
| JavaScript | `glob` (npm) | `glob("**/*.js", cb)` |
| Haskell | `System.FilePath.Glob` | `glob "*.hs"` |
| Rust | `glob` crate | `glob("**/*.rs")?` |
| Go | `path/filepath` | `filepath.Glob("*.md")` |

---

## Regular Expressions — Syntax Overview

::: columns
::: column

### Basic syntax

| Construct | Meaning | Example |
|----------|---------|---------|
| `a` | literal character | `cat` |
| `.` | any character | `c.t` |
| `*` | 0 or more | `a*` |
| `+` | 1 or more | `a+` |
| `?` | 0 or 1 | `colou?r` |
| `{n}` | exactly *n* | `\d{4}` |
| `{n,m}` | from *n* to *m* | `\w{2,5}` |
| `[]` | character class | `[A-Z_]` |
| `[^]` | negated class | `[^0-9]` |
| `^` | start of string | `^https?` |
| `$` | end of string | `\.txt$` |

:::

::: column

### Groups and composition

| Construct | Meaning | Example |
|----------|---------|---------|
| `(re)` | capturing group | `(ab)+` |
| `(?:re)` | non-capturing group | `(?:ab)+` |
| `|` | alternation | `cat|dog` |
| `{n,m}` | group repetition | `(ab){2,4}` |
| nested `()` | composition | `(a(bc))*` |
| `^…$` | full match | `^(ab)+$` |
| precedence | `* + ?` > concat > `|` | `ab|cd*` |

:::
:::

---

## Regular Expressions — Example, Groups (Python)

```python
import re

text = "user:alice id:42"

m = re.search(r"user:(\w+)\s+id:(\d+)", text)

m.group(0)   # full match
m.group(1)   # 'alice'
m.group(2)   # '42'
m.groups()   # ('alice', '42')
```

* groups define submatches
* alternation applies to whole group

---

## Python `re` Module — Overview

::: columns
::: column

### Main functions

\footnotesize

| Function | Purpose | Notes |
|---------|---------|-------|
| `re.match()` | match at start | implicit `^` |
| `re.search()` | find first match | most common |
| `re.findall()` | find all matches | returns list |
| `re.finditer()` | match iterator | memory-efficient |
| `re.fullmatch()` | full string match | implicit `^...$` |
| `re.split()` | split string | regex delimiter |
| `re.sub()` | replace matches | supports groups |
| `re.compile()` | compile pattern | reuse + flags |

\normalsize

:::

::: column

### Flags and notes

**Flags**
- `re.IGNORECASE` / `re.I`
- `re.MULTILINE` / `re.M`
- `re.DOTALL` / `re.S`
- `re.VERBOSE` / `re.X`

**Engine**
- backtracking NFA
- possible exponential behavior

**Practice**
- prefer raw strings: `r"..."`

:::
:::

---

## Regular Expressions — Basic Syntax (Python)

```python
import re

text = "Error 404 at line 23"

re.search(r"\d+", text)          # match number
# <re.Match object; span=(6, 9), match='404'>

re.findall(r"[A-Z][a-z]+", text) # words starting with capital
# ['Error']

re.match(r"Error", text)         # match at start
# <re.Match object; span=(0, 5), match='Error'>

re.fullmatch(r".*\d{2}", text)   # full string match
# <re.Match object; span=(0, 20), match='Error 404 at line 23'>
````
---

## Regular Expressions — Usage in Programming Languages

**Example pattern:** match a sequence of digits (`[0-9]+`)

| Language | Import / Tool | Example usage |
|---------|---------------|---------------|
| Python | `import re` | `re.search(r"[0-9]+", text)` |
| Bash | `grep -E` | `grep -E "[0-9]+" file` |
| Bash | `sed` | `sed -n '/[0-9]+/p' file` |
| C | `<regex.h>` | `regexec(&re, str, 0, NULL, 0)` |
| C++ | `<regex>` | `std::regex_search(s, std::regex("[0-9]+"))` |
| C# | `System.Text.RegularExpressions` | `Regex.Match(s, "[0-9]+")` |
| Java | `java.util.regex` | `Pattern.compile("[0-9]+").matcher(s)` |
| JavaScript | built-in | `text.match(/[0-9]+/)` |
| Rust | `regex` crate | `Regex::new("[0-9]+")?.is_match(text)` |
| Go | `regexp` | `regexp.MatchString("[0-9]+", s)` |
| Haskell | `regex-tdfa` | `text =~ "[0-9]+"` |

- same logical pattern across languages
- syntax and API differ
- engine behavior may differ

---

## `sed` — Stream Editor

::: columns
::: column

### Theory and model

- Line-oriented stream editor
- Processes input sequentially
- Regex-driven commands
- No global memory
- Designed for text transformation
- Typical operations: substitute, delete, print

:::

::: column

### Examples

```bash
# Substitute numbers
sed 's/[0-9]\+/NUM/g' file.txt
````

```bash
# Print matching lines
sed -n '/ERROR/p' app.log
```

```bash
# Delete comments
sed '/^#/d' config.conf
```

```bash
# In-place edit
sed -i 's/foo/bar/g' *.txt
```

:::
:::

---

## `awk` — Pattern–Action Language

::: columns
::: column

### Theory and model

* Line-based processing language
* Regex as conditions
* Automatic field splitting
* Variables and expressions
* Implicit loop over lines
* Small programs, not just filters

:::

::: column

### Examples

```bash
# Print selected fields
awk '{print $1, $3}' data.txt
```

```bash
# Filter by regex
awk '/ERROR/ {print}' app.log
```

```bash
# Simple condition
awk '$3 > 100 {print $1}' table.txt
```

```bash
# Custom separator
awk -F: '{print $1}' /etc/passwd
```

:::
:::

---

## `awk` + `sed` — Combined Usage Example

**Process application logs:** extract error records and anonymize numeric values

```bash
awk '/ERROR/ {print $2, $0}' app.log | sed 's/[0-9]\+/NUM/g'
````

::: columns
::: column

### Explanation

* `awk '/ERROR/ {print $2, $0}'`

  * selects only lines containing `ERROR`
  * prints second field (e.g. module name)
  * keeps the full original line

* `sed 's/[0-9]\+/NUM/g'`

  * replaces all numbers
  * removes IDs, counters, timestamps

:::
::: column

### Example

Input:

```
2025-01-30 ERROR auth failed after 3 attempts
```

Output:

```
auth 2025-01-30 ERROR auth failed after NUM attempts
```

* `awk` → filtering and restructuring
* `sed` → text normalization

:::
:::



