---
title: "Informatics. Basics of Software Development"
subtitle: "Lecture 7 ‚Äî Text data [EARLY DRAFT]"
author: "Konstantin Ushenin"
date: "2026"
---


## Plan

### Encoding
### String in Memory
### Regular Expression

---

# Encoding

---

## Binary-Coded Decimal (BCD) ‚Äî 1950s

::: columns
::: {.column width="60%"}

- Idea
  - Decimal digits encoded separately
  - One digit ‚Üí one 4-bit nibble
  - No positional binary value across digits

- Encoding rules
  - `0‚Äì9` ‚Üí valid
  - `1010‚Äì1111` ‚Üí invalid / reserved

:::

::: {.column width="40%"}

| Decimal | BCD (binary) | Hex |
|--------:|--------------|-----|
| 0 | 0000 | 0x0 |
| 1 | 0001 | 0x1 |
| 2 | 0010 | 0x2 |
| 3 | 0011 | 0x3 |
| 4 | 0100 | 0x4 |
| 5 | 0101 | 0x5 |
| 6 | 0110 | 0x6 |
| 7 | 0111 | 0x7 |
| 8 | 1000 | 0x8 |
| 9 | 1001 | 0x9 |

:::
:::

---

## Morse Code ‚Äî 1830s‚Äì1840s

::: columns
::: {.column width="60%"}

- Type
  - Variable-length code
  - Time-based (dots and dashes)
  - Not binary in storage sense

- Encoding
  - Short signals for frequent letters
  - Long signals for rare letters
  - Explicit symbol boundaries (pauses)

- Properties
  - Human-decodable
  - No fixed symbol width
  - Optimized for manual transmission

- Usage
  - Telegraphy
  - Radio communication
  - Emergency signaling

:::

::: {.column width="40%"}

![](images/International_Morse_Code.png)

:::
:::

---

## ITA2 / Baudot‚ÄìMurray Code ‚Äî 1930s

::: columns
::: {.column width="60%"}

- Type
  - Fixed-length binary code
  - 5 bits ‚Üí 32 code points

- Control symbols
  - LTRS / FIGS ‚Äî mode shift control codes
  - CR (Carriage Return) ‚Äî move to line start
  - LF (Line Feed) ‚Äî move to next line

- Decoding
  - Context-dependent
  - Same bit pattern ‚Üí different symbol
  - Mode persists until next shift

:::

::: {.column width="40%"}

![](images/Ita2.png)

:::
:::

---


## What types of encodings exist?

- **Number of bits per symbol**: 4, 5, 7, 8, 16, ‚Ä¶
  - Examples: BCD (4), Baudot (5), ASCII (7), Latin-1 (8), UTF-16 (16)

- **Fixed-length vs variable-length**
  - Fixed-length: BCD, Baudot, ASCII
  - Variable-length: Morse code, UTF-8

- **Control symbols**
  - Explicit control codes: Baudot (LTRS / FIGS), ASCII (CR, LF, ESC)
  - Implicit control via structure: Morse code (pauses)
  
---

## American Standard Code for Information Interchange (ASCII) ‚Äî 1963

![](images/ASCII_Code_Chart.png)

---

## ASCII ‚Äî 1963

::: columns
::: column

- Control characters
  - `0‚Äì31`, `127`
  - Non-printing (`CR`, `LF`, `ESC`)

- Letters
  - `A‚ÄìZ`: `65‚Äì90`
  - `a‚Äìz`: `97‚Äì122`

**Notes**

- Character ranges are non-contiguous
- Uppercase and lowercase letters have
  - Fixed offset (`+32`)
  - Equal distance in the code table

:::

::: column

- Punctuation ranges

  - `33‚Äì47`: `! " # $ % & ' ( ) * + , - . /`
  - `58‚Äì64`: `: ; < = > ? @`
  - `91‚Äì96`: `[ \ ] ^ _ \``
  - `123‚Äì126`: `{ | } ~`

:::
:::

---

## ASCII Control Characters (Key Ones)

::: columns
::: column

BS (Backspace, 0x08)

 - Moves cursor one position left
 - Overwrites previous character
 - Used on teletypes for character composition

CR (Carriage Return, 0x0D)

 - Move cursor to start of line

LF (Line Feed, 0x0A)

 - Move cursor to next line

ESC (Escape, 0x1B)

 - Starts control sequences
 - Basis for ANSI terminal commands

DEL (Delete, 0x7F)

 - Erase character (historical)

:::

::: column

Diacritic composition using BS

- `a BS ' ‚Üí √°`
- `a BS \ ‚Üí √†`
- `a BS ^ ‚Üí √¢`
- `a BS " ‚Üí √§`
- `o BS / ‚Üí √∏`
- `c BS , ‚Üí √ß`
- `n BS ~ ‚Üí √±`

Neutral / no-op cases

- `a BS a ‚Üí a`
- `a BS _ ‚Üí a`

Idea

- Diacritics were created by overprinting
- No dedicated accented characters in ASCII

:::
:::

---

## Encoding (CP866 and Windows-1251)

::: columns
::: column

![](images/CP866.png)

:::

::: column

![](images/Windows-1251.png)

:::
:::

- –°–∏–º–æ–≤–æ–ª—ã –æ—Ç 0x00 –¥–æ 0x7F - ASCII –∏ –æ–±—ã—á–Ω–æ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã.  0x80-0xFF - –∑–∞–¥–∞–≤–∞–ª–∞—Å—å –Ω–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π —á–∞—Å—Ç—å—é —Ç–∞–±–ª–∏—Ü—ã –∫–æ–¥–∏—Ä–æ–≤–∫–∏
- –ö–æ–¥–∏—Ä–æ–≤–æ–∫ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–æ—Ç–µ–Ω. –†–∞–∑–Ω–∏—Ü–∞ –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–∞—Ö –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö –¥–∞–∂–µ –≤ –æ–¥–Ω–æ–π –∫–æ–º–ø–∞–Ω–∏–∏ –º–æ–≥–ª–∞ –±—ã—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π
- –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤ –∏ –ò–Ω—Ç–µ—Ä–Ω–µ—Ç —Å—Ç—Ä–∞–Ω–∏—Ü –æ—Å—Ç–∞–≤–∞–ª–æ—Å—å –Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–º

---

## Unicode and UTF-8

::: columns
::: column

**Unicode**

* Universal character set
* Assigns unique code point to every character
* Code points: U+0000 to U+10FFFF
* Over 150,000 characters defined

**UTF-8 Encoding**

* Variable-length: 1‚Äì4 bytes per character
* ASCII-compatible (0x00‚Äì0x7F unchanged)
* Self-synchronizing (can find char boundaries)
* No byte-order issues (no BOM needed)

:::

::: column

**UTF-8 Byte Patterns**

| Code point range | Bytes | Byte pattern |
|------------------|-------|--------------|
| U+0000‚ÄìU+007F | 1 | `0xxxxxxx` |
| U+0080‚ÄìU+07FF | 2 | `110xxxxx 10xxxxxx` |
| U+0800‚ÄìU+FFFF | 3 | `1110xxxx 10xxxxxx 10xxxxxx` |
| U+10000‚ÄìU+10FFFF | 4 | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` |

**Examples**

* `A` (U+0041) ‚Üí `0x41` (1 byte)
* `–π` (U+0439) ‚Üí `0xD0 0xB9` (2 bytes)
* `‚Ç¨` (U+20AC) ‚Üí `0xE2 0x82 0xAC` (3 bytes)
* `üòÄ` (U+1F600) ‚Üí `0xF0 0x9F 0x98 0x80` (4 bytes)

:::
:::

---

## Common Encoding Problems

::: columns
::: column

**Mojibake (ÊñáÂ≠óÂåñ„Åë)**

* Text displayed as garbage characters
* Cause: wrong encoding assumed by reader
* Example: UTF-8 text read as Windows-1251

```
"–ü—Ä–∏–≤–µ—Ç" (UTF-8) ‚Üí "√ê≈∏√ë‚Ç¨√ê¬∏√ê¬≤√ê¬µ√ë‚Äö" (as Latin-1)
```

**–ö—Ä–∞–∫–æ–∑—è–±—Ä—ã**

* Russian term for garbled text
* Common in legacy systems
* Often CP866 ‚Üî Windows-1251 mismatch

:::

::: column

**BOM (Byte Order Mark)**

* U+FEFF at file start
* Indicates byte order (UTF-16/32)
* UTF-8 BOM: `0xEF 0xBB 0xBF`
* Often causes issues in scripts/configs

**Surrogate Pairs (UTF-16)**

* Characters beyond U+FFFF
* Encoded as two 16-bit code units
* U+1F600 ‚Üí `0xD83D 0xDE00`
* Source of bugs in JavaScript, Java, C#

:::
:::

---

## Terminal User Interface

::: columns
::: column

![](images/mc.png)

:::

::: column

![](images/htop.png)

:::
:::

- –ü–æ—è–≤–ª–µ–Ω–∏–µ —Å–∏–º–≤–æ–ª–æ–≤ 0x0B-0xFD –ø—Ä–∏–≤–µ–ª–æ –∫ —Ä–∞—Å—Ü–≤–µ—Ç—É –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π —Å –ø—Å–µ–≤–¥–æ–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç–µ–ª–∏: tqdm (Python), htop, top, mc
- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∏: Python (textual, npyscreen), Rust (Ratatui, tui-rs)

---

# String in Memory

---

## ELF executable file (REPEAT)

::: columns
::: column


:::

::: column


![](plots/elf_layout.png)

:::
:::

---

## Virtual memory of the process (REPEAT)

::: columns
::: column


:::

::: column

![](plots/virtual_memory.png)

:::
:::

---

## String literals and memory (.rodata)

::: columns
::: column

```c
#include <stdio.h>

int main(void) {
    const char *p = "Hello";
    printf("%s\n", p);
    return 0;
}
```

:::

::: column


**String literal `"Hello"`**

* Stored in ELF section `.rodata`
* Mapped into process memory as **read-only**
* May be shared between processes
* Lifetime: whole program execution
* Attempt to modify ‚Üí **undefined behavior**


:::
:::

---

## `"Hello"` vs `{'H','e','l','l','o'}`

::: columns
::: column

```c
char a[] = "Hello";
char b[] = {'H','e','l','l','o'};
```

Memory layout:

```
a: 'H' 'e' 'l' 'l' 'o' '\0'
b: 'H' 'e' 'l' 'l' 'o'
```

:::

::: column


**Key difference**

* `"Hello"` is a string literal

  * includes implicit `'\0'`
* Character list does **not**

  * no terminator
  * not a C-string

**Consequences**

* `a` is a valid C-string
* `b` is a raw character array
* Using `b` as string ‚Üí **undefined behavior**


:::
:::

---

## C strings (null-terminated)

::: columns
::: column

```c
char s[] = "Hello";

printf("%s\n", s);      // OK
printf("%zu\n", strlen(s)); // O(n)
```

Memory layout:

```
'H' 'e' 'l' 'l' 'o' '\0'
```

:::

::: column


**C-string model**

* Sequence of `char`
* Terminated by `'\0'`
* Length is **not stored**

**Complexity**

* Access to character ‚Äî **O(1)**
* `strlen`, `printf`, `strcpy` ‚Äî **O(n)**
  (scan until `'\0'`)

**Risks**

* Missing terminator ‚Üí out-of-bounds read
* Buffer overflow ‚Üí undefined behavior


:::
:::

---

## Pascal strings (length-prefixed)

::: columns
::: column

```pascal
var
  s: string[5];
begin
  s := 'Hello';
  writeln(s);
end;
```

Memory layout:

```
5 'H' 'e' 'l' 'l' 'o'
```

:::

::: column


**Pascal string model**

* First byte stores string length
* Characters follow
* No terminating `'\0'`

**Complexity**

* Length access ‚Äî **O(1)**
* Character access ‚Äî **O(1)**

**Properties**

* Binary-safe (may contain zero bytes)
* Maximum length is fixed
* No scanning, no missing-terminator bugs


:::
:::

---

## Dynamic allocation of a C-string

```c
#include <stdlib.h>
#include <string.h>

int main(void) {
    const char *src = "Hello";   // string literal in .rodata

    size_t len = strlen(src);    // number of bytes before '\0' (O(n))

    char *dst = malloc(len + 1); // allocate bytes on heap (+1 for '\0')

    memcpy(dst, src, len + 1);   // copy all bytes including terminator

    free(dst);                   // release heap memory

    return 0;
}
```

---

## Memory leak via function call (C-strings)

```c
void set_string(char **dst) {
    *dst = malloc(6);             // allocate memory on heap
    memcpy(*dst, "Hello", 6);     // copy "Hello\0"
}

char *s = NULL;
set_string(&s);               // s -> heap ("Hello")
set_string(&s);               // previous pointer overwritten
free(s);                      // only second allocation is freed
```

* Losing the last pointer to heap-allocated string means losing the ability to `free` it.
* unreachable memory cannot be freed ‚Üí **memory leak**

---

## Double free (C-strings)

```c
void destroy(char *s) {
    free(s);          // first free
}

char *s = malloc(6);
memcpy(s, "Hello", 6);

destroy(s);           // memory freed
free(s);              // second free (UB)
```

* The same heap pointer is freed twice
* Heap allocator state becomes corrupted
* Result: crash, memory corruption, or silent bugs

---

## String vulnerability: obvious buffer overflow

::: columns
::: column

```c
void vulnerable(const char *input) {
    char buf[8];
    // no bounds checking
    strcpy(buf, input);
}
```

Stack layout (simplified):

```
buf[8]
saved frame pointer
return address   ‚Üê overwritten
```

:::

::: column

* `strcpy` copies until `'\0'`
* buffer size is not checked
* long input overwrites stack data
* stack control data may be corrupted
* leads to crash or code execution

Any C-string function that ignores buffer size is a potential security vulnerability.

:::
:::

---

## `<string.h>` ‚Äî strings and memory (overview)


::: columns
::: column

\footnotesize
```c
/* string length */
size_t strlen(const char *s);
/* string copy */
char *strcpy(char *dst, const char *src);
char *strncpy(char *dst, const char *src, size_t n);
/* string concatenation */
char *strcat(char *dst, const char *src);
char *strncat(char *dst, const char *src, size_t n);
/* string comparison */
int strcmp(const char *a, const char *b);
int strncmp(const char *a, const char *b, size_t n);
/* string search */
char *strchr(const char *s, int c);
char *strrchr(const char *s, int c);
char *strstr(const char *s, const char *sub);
/* tokenization */
char *strtok(char *s, const char *delim);
/* memory operations */
void *memcpy(void *dst, const void *src, size_t n);
void *memmove(void *dst, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int   memcmp(const void *a, const void *b, size_t n);
void *memchr(const void *s, int c, size_t n);
```

\normalsize
:::

::: column

\footnotesize

**Two families of functions**

* *String functions* ‚Äî work with `'\0'`-terminated data
* *Memory functions* ‚Äî work with raw bytes, length is explicit

**Two variants for most operations**

* unbounded: `strcpy`, `strcat`, `strcmp`
* bounded: `strncpy`, `strncat`, `strncmp`

**Important consequences**

* String functions do **not** know buffer size
* Length is discovered by scanning for `'\0'` (often O(n))
* Memory functions always require explicit size
* `memcpy` vs `memmove`: overlap unsafe vs safe

\normalsize

:::
:::


---

## C-string pitfalls and vulnerabilities

::: columns
::: column

**Memory safety**

* Buffer overflow (stack / heap)
* Off-by-one errors
* Missing `'\0'` terminator
* Use-after-free
* Double free
* Memory leaks

**Lifetime and ownership**

* Unclear ownership rules
* Losing last pointer to allocation
* Freeing memory in wrong scope
* Mixing literals and heap strings

:::

::: column

**Logic and API pitfalls**

* No stored length information
* `strlen` and friends are O(n)
* Unsafe standard functions
  (`strcpy`, `strcat`, `sprintf`)
* Misuse of `strncpy`

**Security and correctness**

* Format string vulnerabilities
* Integer overflow in size calculations
* Encoding confusion (UTF-8 byte length)
* Path truncation and TOCTOU bugs

:::
:::

---

## Python strings: creation and basic operations

::: columns
::: column

```python
s1 = "Hello"
s2 = 'World'
s3 = s1 + " " + s2

print(s3)          # Hello World
print(s3.upper()) # HELLO WORLD
print(s3[0])      # H
print(s3[1:5])    # ello
```

:::

::: column

**String creation**

* Strings are created with single or double quotes
* Resulting object type is `str`
* Strings are sequences (support indexing and slicing)

**Basic operations**

* Concatenation creates a new string
* Indexing and slicing are safe
* No null terminator, no manual memory handling

:::
:::

---

## Python strings: encodings and storage

::: columns
::: column

```python
s = "–ü—Ä–∏–≤–µ—Ç"

print(type(s))        # <class 'str'>
print(len(s))         # 6

b = s.encode("utf-8")
print(b)              # bytes
```

:::

::: column

**Encoding model**

* `str` is a sequence of Unicode code points
* Encoding is not visible at language level
* Internally Python uses UCS-1 / UCS-2 / UCS-4
  (chosen automatically)

**Text vs bytes**

* `str` = text (Unicode)
* `bytes` = raw byte sequence
* Encoding converts text to bytes explicitly

:::
:::

---

## Python strings: emoji and encoding errors

::: columns
::: column

```python
# Emoji handling
s = "Hello üòÄ"
print(len(s))         # 7 (code points)

b = s.encode("utf-8")
print(len(b))         # 10 (bytes)

# Encoding errors
s = "–ü—Ä–∏–≤–µ—Ç"
s.encode("ascii")     # UnicodeEncodeError

s.encode("ascii", errors="ignore")
# b''

s.encode("ascii", errors="replace")
# b'??????'
```

:::

::: column

**Emoji in Python**

* Emoji are single code points (mostly)
* `len()` counts code points, not bytes
* Some emoji use multiple code points (ZWJ sequences)

**Handling encoding errors**

* `errors="strict"` ‚Äî raise exception (default)
* `errors="ignore"` ‚Äî skip unencodable chars
* `errors="replace"` ‚Äî use `?` or `\ufffd`
* `errors="backslashreplace"` ‚Äî use `\xNN` escapes

**Decoding errors**

```python
b = b'\xff\xfe'
b.decode("utf-8")  # UnicodeDecodeError
b.decode("utf-8", errors="replace")
# 'ÔøΩÔøΩ'
```

:::
:::

---

## Python strings: immutability

::: columns
::: column

```python
s = "Hello"
s[0] = "h"     # TypeError

t = s.replace("H", "h")

print(s)       # Hello
print(t)       # hello
```

:::

::: column

**Immutability**

* Python strings cannot be modified in place
* Any operation that looks like modification
  creates a new `str` object

**Consequences**

* Strings are safe to share
* Hash value can be cached
* Efficient use as dictionary keys

:::
:::

---

## Python strings: length, hash, interning

::: columns
::: column

```python
s = "hello"

print(len(s))      # O(1)
print(hash(s))     # cached

a = "world"
b = "world"
print(a is b)      # may be True

import sys
c = sys.intern("test")
```

:::

::: column

**Length**

* String length is stored explicitly
* `len(s)` works in O(1)

**Hash**

* Hash value is computed lazily
* Cached inside the string object
* Safe due to immutability

**Interning**

* Some strings are interned automatically
* Explicit interning via `sys.intern`
* Interning is an optimization, not a guarantee

:::
:::

---

## Efficient string concatenation

::: columns
::: column

### Python

```python
# Inefficient
s = ""
for x in parts:
    s += x
```

```python
# Efficient
s = "".join(parts)
```

* `str` is immutable
* `s += x` creates a new string each time, leads to O(n¬≤) total copying


* `join` computes total length first
* allocates memory once and copies each part exactly once
* overall complexity: O(n)

:::

::: column

### Java

```java
// Inefficient
String s = "";
for (String x : parts) {
    s += x;
}
```

```java
// Efficient
StringBuilder sb = new StringBuilder();
for (String x : parts) {
    sb.append(x);
}
String s = sb.toString();
```

* `String` is immutable
* `+` creates temporary objects
* compiler cannot optimize loops

* `StringBuilder` is a mutable buffer
* amortized O(1) append one final string allocation

:::
:::

---

## Python strings and memory ‚Äî overview

\footnotesize

::: columns
::: column

```python
# string length
len(s)
# string concatenation
s + t
"".join(iterable)
# comparison
s == t
s < t
# search
s.find(sub)
s.index(sub)
sub in s
# replacement
s.replace(old, new)
# splitting / joining
s.split(sep)
sep.join(parts)
# encoding / decoding
b = s.encode("utf-8")
s = b.decode("utf-8")
```

:::

::: column

**Two distinct types**

* `str` ‚Äî text (Unicode code points)
* `bytes` ‚Äî raw binary data

**Explicit separation**

* text and binary data are different types
* encoding / decoding is always explicit
* prevents accidental mixing of bytes and text


:::
:::

\normalsize

---

## –í—ã–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫: —Å—Ç–µ–∫ vs –∫—É—á–∞

\footnotesize

| –Ø–∑—ã–∫ | –ü—Ä–∏–º–µ—Ä (—Å—Ç–µ–∫ / static) | –ü—Ä–∏–º–µ—Ä (–∫—É—á–∞) |
|----|------------------------|---------------|
| **C** | `char s[16] = "hi";` | `char *s = malloc(16);` |
| **C++** | `char s[] = "hi";` | `std::string s = "hi";` |
| **Rust** (str) | `let s: &str = "hi";` | ‚Äî |
| **Rust** (String) | ‚Äî | `let s = String::from("hi");` |
| **Java (‚â§ 8)** | ‚Äî | `String s = "hi";` |
| **Java (9+)** | ‚Äî | `String s = "hi";` |
| **Go** | ‚Äî | `s := "hi"` |
| **C#** | ‚Äî | `string s = "hi";` |
| **Python** | ‚Äî | `s = "hi"` |
| **JavaScript** | ‚Äî | `let s = "hi";` |
| **Swift** | ‚Äî | `var s = "hi"` |

\normalsize

–í–æ –≤—Å–µ—Ö —è–∑—ã–∫–∞—Ö —Å–æ —Å–±–æ—Ä–∫–æ–π –º—É—Å–æ—Ä–∞ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –∑–∞—Å—Ç–∞–≤–∏—Ç—å –æ–±—ä–µ–∫—Ç—ã —è–≤–Ω–æ –≤—ã–¥–µ–ª—è—Ç—å—Å—è –Ω–∞ —Å—Ç–µ–∫–µ.

---

## –ö–∞–∫–∏–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç —è–∑—ã–∫–∏ (—É—Ç–æ—á–Ω—ë–Ω–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞)

\footnotesize

| –Ø–∑—ã–∫ | –¢–∏–ø —Å—Ç—Ä–æ–∫–∏ | –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –º–æ–¥–µ–ª—å | –ö–æ–¥–∏—Ä–æ–≤–∫–∞ | –ë–∞–∑–æ–≤–∞—è –µ–¥–∏–Ω–∏—Ü–∞ |
|----|-----------|------------------|-----------|------------------|
| **C** | `char *` | –º–∞—Å—Å–∏–≤ –±–∞–π—Ç | –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ | –±–∞–π—Ç |
| **C++** | `std::string` | –º–∞—Å—Å–∏–≤ –±–∞–π—Ç | –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ | –±–∞–π—Ç |
| **Java (‚â§ 8)** | `String` | `char[]` | UTF-16 | UTF-16 code unit |
| **Java (9+)** | `String` | `byte[] + coder` | Latin-1 / UTF-16 | code unit |
| **C#** | `string` | `char[]` | UTF-16 | UTF-16 code unit |
| **Python** | `str` | Unicode object | UCS-1/2/4 | code point |
| **Go** | `string` | `(ptr, len)` | UTF-8 (—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ) | –±–∞–π—Ç |
| **Rust (`&str`)** | slice | `(ptr, len)` | UTF-8 (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) | –±–∞–π—Ç |
| **Rust (`String`)** | owning buffer | `Vec<u8>` | UTF-8 (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ) | –±–∞–π—Ç |
| **JavaScript** | `string` | UTF-16 | UTF-16 | code unit |
| **Swift** | `String` | Unicode | UTF-8/16/32 (–∞–≤—Ç–æ) | grapheme cluster |
| **PHP** | `string` | –±–∞–π—Ç—ã | –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ | –±–∞–π—Ç |

\normalsize

---

## –°—Ç—Ä–æ–∫–∏: –º—É—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å, —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ, –∏–Ω—Ç–µ—Ä–Ω–∏–Ω–≥

\footnotesize

| –Ø–∑—ã–∫ | –ú—É—Ç–∞–±–µ–ª—å–Ω–æ—Å—Ç—å | –•—Ä–∞–Ω–µ–Ω–∏–µ —Ö–µ—à–∞ | –ò–Ω—Ç–µ—Ä–Ω–∏–Ω–≥ |
|----|---------------------|--------------------------|-----------------|
| **C** | –¥–∞ | –Ω–µ—Ç | –Ω–µ—Ç |
| **C++** | –¥–∞ (`std::string`) | –Ω–µ—Ç | –Ω–µ—Ç |
| **Java** | –Ω–µ—Ç (immutable) | –¥–∞ | –¥–∞ (–ª–∏—Ç–µ—Ä–∞–ª—ã, `intern()`) |
| **C#** | –Ω–µ—Ç (immutable) | –¥–∞ | –¥–∞ (–ª–∏—Ç–µ—Ä–∞–ª—ã, `String.Intern`) |
| **Python** | –Ω–µ—Ç (immutable) | –¥–∞ | —á–∞—Å—Ç–∏—á–Ω–æ (—Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è, `sys.intern`) |
| **Go** | –Ω–µ—Ç (immutable) | –Ω–µ—Ç | –Ω–µ—Ç |
| **Rust (`String`)** | –¥–∞ | –Ω–µ—Ç | –Ω–µ—Ç |
| **Rust (`&str`)** | –Ω–µ—Ç | –Ω–µ—Ç | –Ω–µ—Ç |
| **JavaScript** | –Ω–µ—Ç (immutable) | –Ω–µ—Ç | —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–≤–∏–∂–∫–∞ |
| **Swift** | –ª–æ–≥–∏—á–µ—Å–∫–∏ –Ω–µ—Ç (CoW) | –Ω–µ—Ç | —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è |
| **Ruby** | –¥–∞ | —á–∞—Å—Ç–∏—á–Ω–æ (–∏–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ—Ç—Å—è) | –Ω–µ—Ç (–∏–Ω—Ç–µ—Ä–Ω—è—Ç—Å—è `Symbol`) |
| **PHP** | –¥–∞ | –Ω–µ—Ç | –Ω–µ—Ç |

\normalsize

---

## –°—Ç—Ä–æ–∫–∏: –¥–ª–∏–Ω–∞ –∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å –¥–æ—Å—Ç—É–ø–∞

\footnotesize

| –Ø–∑—ã–∫ | –î–ª–∏–Ω–∞ | –ö–æ–¥–∏—Ä. | len | n-–π –±–∞–π—Ç | n-—è –µ–¥. |
|----|-------|--------|-----|----------|---------|
| **C** | –Ω–µ—Ç | ‚Äî | **O(n)** | O(1) | O(1) |
| **C++** | –¥–∞ | ‚Äî | O(1) | O(1) | O(1) |
| **Java ‚â§8** | –¥–∞ | UTF-16 | O(1) | O(1) | O(1) |
| **Java 9+** | –¥–∞ | L1/16 | O(1) | O(1) | O(1) |
| **C#** | –¥–∞ | UTF-16 | O(1) | O(1) | O(1) |
| **Python** | –¥–∞ | auto | O(1) | O(1) | O(1) |
| **Go** | –¥–∞ | **UTF-8** | O(1) | O(1) | **O(n)** |
| **Rust** `&str` | –¥–∞ | **UTF-8** | O(1) | O(1) | **O(n)** |
| **Rust** `String` | –¥–∞ | **UTF-8** | O(1) | O(1) | **O(n)** |
| **JS** | –¥–∞ | UTF-16 | O(1) | O(1) | O(1) |
| **Swift** | –¥–∞ | auto | **O(n)** | O(1) | **O(n)** |
| **PHP** | –¥–∞ | ‚Äî | O(1) | O(1) | O(1) |

\normalsize

---

# Regular Expression

---

## Wildcards (glob) vs Regular Expressions

::: columns
::: column

### Wildcards (glob)
- Filename pattern matching
- Implemented by shell / filesystem libraries
- Expanded **before** program execution
- Operates on paths
- Limited expressive power
- No groups or alternation
- Linear-time matching

:::

::: column

### Regular expressions
- Pattern matching over strings
- Implemented by programs / libraries
- Evaluated **during** program execution
- Operate on text streams
- High expressive power
- Groups, alternation, repetition
- DFA / NFA / backtracking engines

:::
:::

---

### Glob syntax

| Pattern | Meaning | Example |
|--------|---------|---------|
| `*` | any string (incl. empty) | `*.txt` |
| `?` | exactly one character | `file_?.dat` |
| `[abc]` | one of listed characters | `img_[abc].png` |
| `[a-z]` | character range | `data_[0-9].csv` |
| `[^a-z]` | negation | `[^._]*` |
| `**` | recursive match | `src/**/*.py` |

- `/` is not matched by `*` or `?`
- `**` is shell- and library-dependent

---

## Wildcards (glob) ‚Äî Python Example

**Scenario:** concatenate all log files from a directory

```python
from pathlib import Path

log_dir = Path("logs")
output = Path("all_logs.txt")

with output.open("w") as out:
    for log_file in sorted(log_dir.glob("*.log")):
        out.write(f"\n=== {log_file.name} ===\n")
        out.write(log_file.read_text())
```

---

## Wildcards (glob) ‚Äî Bash Usage Examples

\footnotesize

```bash
ls *.txt # List all text files

rm *.tmp *.bak # Remove temporary files

gcc src/*.c -o app # Compile all C sources

tar -czf logs.tar.gz logs/2025-*.log # Archive logs by date

grep "ERROR" /var/log/app/app_*.log # Search errors in rotated logs

cp images/*.{png,jpg} backup/ # Copy all images

wc -l data_??.csv # Count lines in CSV files

ls src/**/test_*.py # Find test files recursively (bash ‚â• 4)

ls [!.]* # Exclude hidden files
```

\normalsize

---

## Wildcards (glob) ‚Äî Usage in Programming Languages

| Language | Import / Tool | Example usage |
|---------|---------------|---------------|
| Python | `import glob` | `glob.glob("*.txt")` |
| Python | `from pathlib import Path` | `Path(".").glob("*.py")` |
| Bash | shell builtin | `ls *.txt` |
| Make | implicit glob | `SRC = *.c` |
| C | `<glob.h>` | `glob("*.log", 0, NULL, &g)` |
| C++ | `<filesystem>` | `for (auto& p : fs::directory_iterator("."))` |
| C# | `System.IO` | `Directory.GetFiles(".", "*.txt")` |
| Java | `java.nio.file` | `Files.newDirectoryStream(p, "*.txt")` |
| JavaScript | `glob` (npm) | `glob("**/*.js", cb)` |
| Haskell | `System.FilePath.Glob` | `glob "*.hs"` |
| Rust | `glob` crate | `glob("**/*.rs")?` |
| Go | `path/filepath` | `filepath.Glob("*.md")` |

---

## Regular Expressions ‚Äî Syntax Overview

::: columns
::: column

### Basic syntax

| Construct | Meaning | Example |
|----------|---------|---------|
| `a` | literal character | `cat` |
| `.` | any character | `c.t` |
| `*` | 0 or more | `a*` |
| `+` | 1 or more | `a+` |
| `?` | 0 or 1 | `colou?r` |
| `{n}` | exactly *n* | `\d{4}` |
| `{n,m}` | from *n* to *m* | `\w{2,5}` |
| `[]` | character class | `[A-Z_]` |
| `[^]` | negated class | `[^0-9]` |
| `^` | start of string | `^https?` |
| `$` | end of string | `\.txt$` |

:::

::: column

### Groups and composition

| Construct | Meaning | Example |
|----------|---------|---------|
| `(re)` | capturing group | `(ab)+` |
| `(?:re)` | non-capturing group | `(?:ab)+` |
| `|` | alternation | `cat|dog` |
| `{n,m}` | group repetition | `(ab){2,4}` |
| nested `()` | composition | `(a(bc))*` |
| `^‚Ä¶$` | full match | `^(ab)+$` |
| precedence | `* + ?` > concat > `|` | `ab|cd*` |

:::
:::

---

## Regular Expressions ‚Äî Example, Groups (Python)

```python
import re

text = "user:alice id:42"

m = re.search(r"user:(\w+)\s+id:(\d+)", text)

m.group(0)   # full match
m.group(1)   # 'alice'
m.group(2)   # '42'
m.groups()   # ('alice', '42')
```

* groups define submatches
* alternation applies to whole group

---

## Python `re` Module ‚Äî Overview

::: columns
::: column

### Main functions

\footnotesize

| Function | Purpose | Notes |
|---------|---------|-------|
| `re.match()` | match at start | implicit `^` |
| `re.search()` | find first match | most common |
| `re.findall()` | find all matches | returns list |
| `re.finditer()` | match iterator | memory-efficient |
| `re.fullmatch()` | full string match | implicit `^...$` |
| `re.split()` | split string | regex delimiter |
| `re.sub()` | replace matches | supports groups |
| `re.compile()` | compile pattern | reuse + flags |

\normalsize

:::

::: column

### Flags and notes

**Flags**
- `re.IGNORECASE` / `re.I`
- `re.MULTILINE` / `re.M`
- `re.DOTALL` / `re.S`
- `re.VERBOSE` / `re.X`

**Engine**
- backtracking NFA
- possible exponential behavior

**Practice**
- prefer raw strings: `r"..."`

:::
:::

---

## Regular Expressions ‚Äî Basic Syntax (Python)

```python
import re

text = "Error 404 at line 23"

re.search(r"\d+", text)          # match number
# <re.Match object; span=(6, 9), match='404'>

re.findall(r"[A-Z][a-z]+", text) # words starting with capital
# ['Error']

re.match(r"Error", text)         # match at start
# <re.Match object; span=(0, 5), match='Error'>

re.fullmatch(r".*\d{2}", text)   # full string match
# <re.Match object; span=(0, 20), match='Error 404 at line 23'>
```
---

## Regular Expressions ‚Äî Usage in Programming Languages

**Example pattern:** match a sequence of digits (`[0-9]+`)

| Language | Import / Tool | Example usage |
|---------|---------------|---------------|
| Python | `import re` | `re.search(r"[0-9]+", text)` |
| Bash | `grep -E` | `grep -E "[0-9]+" file` |
| Bash | `sed` | `sed -n '/[0-9]+/p' file` |
| C | `<regex.h>` | `regexec(&re, str, 0, NULL, 0)` |
| C++ | `<regex>` | `std::regex_search(s, std::regex("[0-9]+"))` |
| C# | `System.Text.RegularExpressions` | `Regex.Match(s, "[0-9]+")` |
| Java | `java.util.regex` | `Pattern.compile("[0-9]+").matcher(s)` |
| JavaScript | built-in | `text.match(/[0-9]+/)` |
| Rust | `regex` crate | `Regex::new("[0-9]+")?.is_match(text)` |
| Go | `regexp` | `regexp.MatchString("[0-9]+", s)` |
| Haskell | `regex-tdfa` | `text =~ "[0-9]+"` |

- same logical pattern across languages
- syntax and API differ
- engine behavior may differ

---

## `sed` ‚Äî Stream Editor

::: columns
::: column

### Theory and model

- Line-oriented stream editor
- Processes input sequentially
- Regex-driven commands
- No global memory
- Designed for text transformation
- Typical operations: substitute, delete, print

:::

::: column

### Examples

```bash
# Substitute numbers
sed 's/[0-9]\+/NUM/g' file.txt
```

```bash
# Print matching lines
sed -n '/ERROR/p' app.log
```

```bash
# Delete comments
sed '/^#/d' config.conf
```

```bash
# In-place edit
sed -i 's/foo/bar/g' *.txt
```

:::
:::

---

## `awk` ‚Äî Pattern‚ÄìAction Language

::: columns
::: column

### Theory and model

* Line-based processing language
* Regex as conditions
* Automatic field splitting
* Variables and expressions
* Implicit loop over lines
* Small programs, not just filters

:::

::: column

### Examples

```bash
# Print selected fields
awk '{print $1, $3}' data.txt
```

```bash
# Filter by regex
awk '/ERROR/ {print}' app.log
```

```bash
# Simple condition
awk '$3 > 100 {print $1}' table.txt
```

```bash
# Custom separator
awk -F: '{print $1}' /etc/passwd
```

:::
:::

---

## `awk` + `sed` ‚Äî Combined Usage Example

**Process application logs:** extract error records and anonymize numeric values

```bash
awk '/ERROR/ {print $2, $0}' app.log | sed 's/[0-9]\+/NUM/g'
```

::: columns
::: column

### Explanation

* `awk '/ERROR/ {print $2, $0}'`

  * selects only lines containing `ERROR`
  * prints second field (e.g. module name)
  * keeps the full original line

* `sed 's/[0-9]\+/NUM/g'`

  * replaces all numbers
  * removes IDs, counters, timestamps

:::
::: column

### Example

Input:

```
2025-01-30 ERROR auth failed after 3 attempts
```

Output:

```
auth 2025-01-30 ERROR auth failed after NUM attempts
```

* `awk` ‚Üí filtering and restructuring
* `sed` ‚Üí text normalization

:::
:::

---

