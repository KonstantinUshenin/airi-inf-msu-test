---
title: "Informatics. Basics of Software Development"
subtitle: "Lecture 7 — Text data [EARLY DRAFT]"
author: "Konstantin Ushenin"
date: "2026"
---


## Plan

### Encoding
### String in Memory
### Reqular Expression

---

# Encoding

---

## Binary-Coded Decimal (BCD) — 1950s

::: columns
::: {.column width="60%"}

- Idea
  - Decimal digits encoded separately
  - One digit → one 4-bit nibble
  - No positional binary value across digits

- Encoding rules
  - `0–9` → valid
  - `1010–1111` → invalid / reserved

:::

::: {.column width="40%"}

| Decimal | BCD (binary) | Hex |
|--------:|--------------|-----|
| 0 | 0000 | 0x0 |
| 1 | 0001 | 0x1 |
| 2 | 0010 | 0x2 |
| 3 | 0011 | 0x3 |
| 4 | 0100 | 0x4 |
| 5 | 0101 | 0x5 |
| 6 | 0110 | 0x6 |
| 7 | 0111 | 0x7 |
| 8 | 1000 | 0x8 |
| 9 | 1001 | 0x9 |

:::
:::

---

## Morse Code — 1830s–1840s

::: columns
::: {.column width="60%"}

- Type
  - Variable-length code
  - Time-based (dots and dashes)
  - Not binary in storage sense

- Encoding
  - Short signals for frequent letters
  - Long signals for rare letters
  - Explicit symbol boundaries (pauses)

- Properties
  - Human-decodable
  - No fixed symbol width
  - Optimized for manual transmission

- Usage
  - Telegraphy
  - Radio communication
  - Emergency signaling

:::

::: {.column width="40%"}

![](images/International_Morse_Code.png)

:::
:::

---

## ITA2 / Baudot–Murray Code — 1930s

::: columns
::: {.column width="60%"}

- Type
  - Fixed-length binary code
  - 5 bits → 32 code points

- Control symbols
  - LTRS / FIGS — mode shift control codes
  - CR (Carriage Return) — move to line start
  - LF (Line Feed) — move to next line

- Decoding
  - Context-dependent
  - Same bit pattern → different symbol
  - Mode persists until next shift

:::

::: {.column width="40%"}

![](images/Ita2.png)

:::
:::

---


## What types of encodings exist?

- **Number of bits per symbol**: 4, 5, 7, 8, 16, …
  - Examples: BCD (4), Baudot (5), ASCII (7), Latin-1 (8), UTF-16 (16)

- **Fixed-length vs variable-length**
  - Fixed-length: BCD, Baudot, ASCII
  - Variable-length: Morse code, UTF-8

- **Control symbols**
  - Explicit control codes: Baudot (LTRS / FIGS), ASCII (CR, LF, ESC)
  - Implicit control via structure: Morse code (pauses)
  
---

## American Standard Code for Information Interchange (ASCII) — 1963

![](images/ASCII_Code_Chart.png)

---

## ASCII — 1963

::: columns
::: column

- Control characters
  - `0–31`, `127`
  - Non-printing (`CR`, `LF`, `ESC`)

- Letters
  - `A–Z`: `65–90`
  - `a–z`: `97–122`

**Notes**

- Character ranges are non-contiguous
- Uppercase and lowercase letters have
  - Fixed offset (`+32`)
  - Equal distance in the code table

:::

::: column

- Punctuation ranges

  - `33–47`: `! " # $ % & ' ( ) * + , - . /`
  - `58–64`: `: ; < = > ? @`
  - `91–96`: `[ \ ] ^ _ \``
  - `123–126`: `{ | } ~`

:::
:::

---

## ASCII Control Characters (Key Ones)

::: columns
::: column

BS (Backspace, 0x08)

 - Moves cursor one position left
 - Overwrites previous character
 - Used on teletypes for character composition

CR (Carriage Return, 0x0D)

 - Move cursor to start of line

LF (Line Feed, 0x0A)

 - Move cursor to next line

ESC (Escape, 0x1B)

 - Starts control sequences
 - Basis for ANSI terminal commands

DEL (Delete, 0x7F)

 - Erase character (historical)

:::

::: column

Diacritic composition using BS

- `a BS ' → á`
- `a BS \ → à`
- `a BS ^ → â`
- `a BS " → ä`
- `o BS / → ø`
- `c BS , → ç`
- `n BS ~ → ñ`

Neutral / no-op cases

- `a BS a → a`
- `a BS _ → a`

Idea

- Diacritics were created by overprinting
- No dedicated accented characters in ASCII

:::
:::

---

## Encoding (CP866 and Windows-1251)

::: columns
::: column

![](images/CP866.png)

:::

::: column

![](images/Windows-1251.png)

:::
:::

- Симоволы от 0x00 до 0x7F - ASCII и обычно универсальны.  0x80-0xFF - задавалась национальной частью таблицы кодировки
- Кодировок существует несколько сотен. Разница в кодировках предложенных даже в одной компании могла быть критической
- Отображение документов и Интернет страниц оставалось непредсказуемым

---

## Terminal User Interface

::: columns
::: column

![](images/mc.png)

:::

::: column

![](images/htop.png)

:::
:::

- Появление символов 0xOB-0xFD привело к расцвету приложений с псевдоинтерфейсом
- Современные представители: tqdm (Python), htop, top, mc
- Современные фреймворки: Python (textual, npyscreen), Rust (Ratatui, tui-rs)

---

# String in Memory

---

## ELF executable file (REPEAT)

::: columns
::: column


:::

::: column


![](plots/elf_layout.png)

:::
:::

---

## Virtual memory of the process (REPEAT)

::: columns
::: column


:::

::: column

![](plots/virtual_memory.png)

:::
:::

---

## String literals and memory (.rodata)

::: columns
::: column

```c
#include <stdio.h>

int main(void) {
    const char *p = "Hello";
    printf("%s\n", p);
    return 0;
}
````

:::

::: column


**String literal `"Hello"`**

* Stored in ELF section `.rodata`
* Mapped into process memory as **read-only**
* May be shared between processes
* Lifetime: whole program execution
* Attempt to modify → **undefined behavior**


:::
:::

---

## `"Hello"` vs `{'H','e','l','l','o'}`

::: columns
::: column

```c
char a[] = "Hello";
char b[] = {'H','e','l','l','o'};
```

Memory layout:

```
a: 'H' 'e' 'l' 'l' 'o' '\0'
b: 'H' 'e' 'l' 'l' 'o'
```

:::

::: column


**Key difference**

* `"Hello"` is a string literal

  * includes implicit `'\0'`
* Character list does **not**

  * no terminator
  * not a C-string

**Consequences**

* `a` is a valid C-string
* `b` is a raw character array
* Using `b` as string → **undefined behavior**


:::
:::

---

## C strings (null-terminated)

::: columns
::: column

```c
char s[] = "Hello";

printf("%s\n", s);      // OK
printf("%zu\n", strlen(s)); // O(n)
```

Memory layout:

```
'H' 'e' 'l' 'l' 'o' '\0'
```

:::

::: column


**C-string model**

* Sequence of `char`
* Terminated by `'\0'`
* Length is **not stored**

**Complexity**

* Access to character — **O(1)**
* `strlen`, `printf`, `strcpy` — **O(n)**
  (scan until `'\0'`)

**Risks**

* Missing terminator → out-of-bounds read
* Buffer overflow → undefined behavior


:::
:::

---

## Pascal strings (length-prefixed)

::: columns
::: column

```pascal
var
  s: string[5];
begin
  s := 'Hello';
  writeln(s);
end;
```

Memory layout:

```
5 'H' 'e' 'l' 'l' 'o'
```

:::

::: column


**Pascal string model**

* First byte stores string length
* Characters follow
* No terminating `'\0'`

**Complexity**

* Length access — **O(1)**
* Character access — **O(1)**

**Properties**

* Binary-safe (may contain zero bytes)
* Maximum length is fixed
* No scanning, no missing-terminator bugs


:::
:::

---

## Dynamic allocation of a C-string

```c
#include <stdlib.h>
#include <string.h>

int main(void) {
    const char *src = "Hello";   // string literal in .rodata

    size_t len = strlen(src);    // number of bytes before '\0' (O(n))

    char *dst = malloc(len + 1); // allocate bytes on heap (+1 for '\0')

    memcpy(dst, src, len + 1);   // copy all bytes including terminator

    free(dst);                   // release heap memory

    return 0;
}
```

---

## Memory leak via function call (C-strings)

```c
void set_string(char **dst) {
    *dst = malloc(6);             // allocate memory on heap
    memcpy(*dst, "Hello", 6);     // copy "Hello\0"
}

char *s = NULL;
set_string(&s);               // s -> heap ("Hello")
set_string(&s);               // previous pointer overwritten
free(s);                      // only second allocation is freed
}
```

* Losing the last pointer to heap-allocated string means losing the ability to `free` it.
* unreachable memory cannot be freed → **memory leak**

---

## Double free (C-strings)

```c
void destroy(char *s) {
    free(s);          // first free
}

char *s = malloc(6);
memcpy(s, "Hello", 6);

destroy(s);           // memory freed
free(s);              // second free (UB)
````

* The same heap pointer is freed twice
* Heap allocator state becomes corrupted
* Result: crash, memory corruption, or silent bugs

---

## String vulnerability: obvious buffer overflow

::: columns
::: column

```c
void vulnerable(const char *input) {
    char buf[8];
    // no bounds checking
    strcpy(buf, input);
}
```

Stack layout (simplified):

```
buf[8]
saved frame pointer
return address   ← overwritten
```

:::

::: column

* `strcpy` copies until `'\0'`
* buffer size is not checked
* long input overwrites stack data
* stack control data may be corrupted
* leads to crash or code execution

Any C-string function that ignores buffer size is a potential security vulnerability.

:::
:::

---

## `<string.h>` — strings and memory (overview)


::: columns
::: column

\footnotesize
```c
/* string length */
size_t strlen(const char *s);
/* string copy */
char *strcpy(char *dst, const char *src);
char *strncpy(char *dst, const char *src, size_t n);
/* string concatenation */
char *strcat(char *dst, const char *src);
char *strncat(char *dst, const char *src, size_t n);
/* string comparison */
int strcmp(const char *a, const char *b);
int strncmp(const char *a, const char *b, size_t n);
/* string search */
char *strchr(const char *s, int c);
char *strrchr(const char *s, int c);
char *strstr(const char *s, const char *sub);
/* tokenization */
char *strtok(char *s, const char *delim);
/* memory operations */
void *memcpy(void *dst, const void *src, size_t n);
void *memmove(void *dst, const void *src, size_t n);
void *memset(void *s, int c, size_t n);
int   memcmp(const void *a, const void *b, size_t n);
void *memchr(const void *s, int c, size_t n);
```

\normalsize
:::

::: column

\footnotesize

**Two families of functions**

* *String functions* — work with `'\0'`-terminated data
* *Memory functions* — work with raw bytes, length is explicit

**Two variants for most operations**

* unbounded: `strcpy`, `strcat`, `strcmp`
* bounded: `strncpy`, `strncat`, `strncmp`

**Important consequences**

* String functions do **not** know buffer size
* Length is discovered by scanning for `'\0'` (often O(n))
* Memory functions always require explicit size
* `memcpy` vs `memmove`: overlap unsafe vs safe

\normalsize

:::
:::


---

## C-string pitfalls and vulnerabilities

::: columns
::: column

**Memory safety**

* Buffer overflow (stack / heap)
* Off-by-one errors
* Missing `'\0'` terminator
* Use-after-free
* Double free
* Memory leaks

**Lifetime and ownership**

* Unclear ownership rules
* Losing last pointer to allocation
* Freeing memory in wrong scope
* Mixing literals and heap strings

:::

::: column

**Logic and API pitfalls**

* No stored length information
* `strlen` and friends are O(n)
* Unsafe standard functions
  (`strcpy`, `strcat`, `sprintf`)
* Misuse of `strncpy`

**Security and correctness**

* Format string vulnerabilities
* Integer overflow in size calculations
* Encoding confusion (UTF-8 byte length)
* Path truncation and TOCTOU bugs

:::
:::

---

## Python strings: creation and basic operations

::: columns
::: column

```python
s1 = "Hello"
s2 = 'World'
s3 = s1 + " " + s2

print(s3)          # Hello World
print(s3.upper()) # HELLO WORLD
print(s3[0])      # H
print(s3[1:5])    # ello
```

:::

::: column

**String creation**

* Strings are created with single or double quotes
* Resulting object type is `str`
* Strings are sequences (support indexing and slicing)

**Basic operations**

* Concatenation creates a new string
* Indexing and slicing are safe
* No null terminator, no manual memory handling

:::
:::

---

## Python strings: encodings and storage

::: columns
::: column

```python
s = "Привет"

print(type(s))        # <class 'str'>
print(len(s))         # 6

b = s.encode("utf-8")
print(b)              # bytes
```

:::

::: column

**Encoding model**

* `str` is a sequence of Unicode code points
* Encoding is not visible at language level
* Internally Python uses UCS-1 / UCS-2 / UCS-4
  (chosen automatically)

**Text vs bytes**

* `str` = text (Unicode)
* `bytes` = raw byte sequence
* Encoding converts text to bytes explicitly

:::
:::

---

## Python strings: immutability

::: columns
::: column

```python
s = "Hello"
s[0] = "h"     # TypeError

t = s.replace("H", "h")

print(s)       # Hello
print(t)       # hello
```

:::

::: column

**Immutability**

* Python strings cannot be modified in place
* Any operation that looks like modification
  creates a new `str` object

**Consequences**

* Strings are safe to share
* Hash value can be cached
* Efficient use as dictionary keys

:::
:::

---

## Python strings: length, hash, interning

::: columns
::: column

```python
s = "hello"

print(len(s))      # O(1)
print(hash(s))     # cached

a = "world"
b = "world"
print(a is b)      # may be True

import sys
c = sys.intern("test")
```

:::

::: column

**Length**

* String length is stored explicitly
* `len(s)` works in O(1)

**Hash**

* Hash value is computed lazily
* Cached inside the string object
* Safe due to immutability

**Interning**

* Some strings are interned automatically
* Explicit interning via `sys.intern`
* Interning is an optimization, not a guarantee

:::
:::

---

## Efficient string concatenation

::: columns
::: column

### Python

```python
# Inefficient
s = ""
for x in parts:
    s += x
````

```python
# Efficient
s = "".join(parts)
```

* `str` is immutable
* `s += x` creates a new string each time, leads to O(n²) total copying


* `join` computes total length first
* allocates memory once and copies each part exactly once
* overall complexity: O(n)

:::

::: column

### Java

```java
// Inefficient
String s = "";
for (String x : parts) {
    s += x;
}
```

```java
// Efficient
StringBuilder sb = new StringBuilder();
for (String x : parts) {
    sb.append(x);
}
String s = sb.toString();
```

* `String` is immutable
* `+` creates temporary objects
* compiler cannot optimize loops

* `StringBuilder` is a mutable buffer
* amortized O(1) append one final string allocation

:::
:::

---

## Python strings and memory — overview

\footnotesize

::: columns
::: column

```python
# string length
len(s)
# string concatenation
s + t
"".join(iterable)
# comparison
s == t
s < t
# search
s.find(sub)
s.index(sub)
sub in s
# replacement
s.replace(old, new)
# splitting / joining
s.split(sep)
sep.join(parts)
# encoding / decoding
b = s.encode("utf-8")
s = b.decode("utf-8")
```

:::

::: column

**Two distinct types**

* `str` — text (Unicode code points)
* `bytes` — raw binary data

**Explicit separation**

* text and binary data are different types
* encoding / decoding is always explicit
* prevents accidental mixing of bytes and text


:::
:::

\normalsize

---

## Выделение строк: стек vs куча

\footnotesize

| Язык | Пример (стек / static) | Пример (куча) |
|----|------------------------|---------------|
| **C** | `char s[16] = "hi";` | `char *s = malloc(16);` |
| **C++** | `char s[] = "hi";` | `std::string s = "hi";` |
| **Rust** (str) | `let s: &str = "hi";` | — |
| **Rust** (String) | — | `let s = String::from("hi");` |
| **Java (≤ 8)** | — | `String s = "hi";` |
| **Java (9+)** | — | `String s = "hi";` |
| **Go** | — | `s := "hi"` |
| **C#** | — | `string s = "hi";` |
| **Python** | — | `s = "hi"` |
| **JavaScript** | — | `let s = "hi";` |
| **Swift** | — | `var s = "hi"` |

\normalsize

Во всех языках со сборкой мусора вы не можете заставить объекты явно выделяться на стеке.

---

## Какие кодировки используют языки (уточнённая таблица)

\footnotesize

| Язык | Тип строки | Внутренняя модель | Кодировка | Базовая единица |
|----|-----------|------------------|-----------|------------------|
| **C** | `char *` | массив байт | не определена | байт |
| **C++** | `std::string` | массив байт | не определена | байт |
| **Java (≤ 8)** | `String` | `char[]` | UTF-16 | UTF-16 code unit |
| **Java (9+)** | `String` | `byte[] + coder` | Latin-1 / UTF-16 | code unit |
| **C#** | `string` | `char[]` | UTF-16 | UTF-16 code unit |
| **Python** | `str` | Unicode object | UCS-1/2/4 | code point |
| **Go** | `string` | `(ptr, len)` | UTF-8 (соглашение) | байт |
| **Rust (`&str`)** | slice | `(ptr, len)` | UTF-8 (обязательно) | байт |
| **Rust (`String`)** | owning buffer | `Vec<u8>` | UTF-8 (обязательно) | байт |
| **JavaScript** | `string` | UTF-16 | UTF-16 | code unit |
| **Swift** | `String` | Unicode | UTF-8/16/32 (авто) | grapheme cluster |
| **PHP** | `string` | байты | не определена | байт |

\normalsize

---

## Строки: мутабельность, хеширование, интернинг

\footnotesize

| Язык | Мутабельность | Хранение хеша | Интернинг |
|----|---------------------|--------------------------|-----------------|
| **C** | да | нет | нет |
| **C++** | да (`std::string`) | нет | нет |
| **Java** | нет (immutable) | да | да (литералы, `intern()`) |
| **C#** | нет (immutable) | да | да (литералы, `String.Intern`) |
| **Python** | нет (immutable) | да | частично (реализация, `sys.intern`) |
| **Go** | нет (immutable) | нет | нет |
| **Rust (`String`)** | да | нет | нет |
| **Rust (`&str`)** | нет | нет | нет |
| **JavaScript** | нет (immutable) | нет | реализация движка |
| **Swift** | логически нет (CoW) | нет | реализация |
| **Ruby** | да | частично (инвалидируется) | нет (интернятся `Symbol`) |
| **PHP** | да | нет | нет |

\normalsize

---

## Строки: длина и сложность доступа

\footnotesize

| Язык | Длина | Кодир. | len | n-й байт | n-я ед. |
|----|-------|--------|-----|----------|---------|
| **C** | нет | — | **O(n)** | O(1) | O(1) |
| **C++** | да | — | O(1) | O(1) | O(1) |
| **Java ≤8** | да | UTF-16 | O(1) | O(1) | O(1) |
| **Java 9+** | да | L1/16 | O(1) | O(1) | O(1) |
| **C#** | да | UTF-16 | O(1) | O(1) | O(1) |
| **Python** | да | auto | O(1) | O(1) | O(1) |
| **Go** | да | **UTF-8** | O(1) | O(1) | **O(n)** |
| **Rust** `&str` | да | **UTF-8** | O(1) | O(1) | **O(n)** |
| **Rust** `String` | да | **UTF-8** | O(1) | O(1) | **O(n)** |
| **JS** | да | UTF-16 | O(1) | O(1) | O(1) |
| **Swift** | да | auto | **O(n)** | O(1) | **O(n)** |
| **PHP** | да | — | O(1) | O(1) | O(1) |

\normalsize

---

# Regular Expression

---

## Wildcards (glob) vs Regular Expressions

::: columns
::: column

### Wildcards (glob)
- Filename pattern matching
- Implemented by shell / filesystem libraries
- In shell: expanded **before** program execution
- In libraries: evaluated at runtime (`glob.glob`, `Path.glob`)
- Operates on paths
- Limited expressive power
- No groups or alternation
- Linear-time matching

:::

::: column

### Regular expressions
- Pattern matching over strings
- Implemented by programs / libraries
- Evaluated **during** program execution
- Operate on text streams
- High expressive power
- Groups, alternation, repetition
- DFA / NFA / backtracking engines

:::
:::

---

### Glob syntax

| Pattern | Meaning | Example |
|--------|---------|---------|
| `*` | any string (incl. empty) | `*.txt` |
| `?` | exactly one character | `file_?.dat` |
| `[abc]` | one of listed characters | `img_[abc].png` |
| `[a-z]` | character range | `data_[0-9].csv` |
| `[^a-z]` | negation | `[^._]*` |
| `**` | recursive match | `src/**/*.py` |

- `/` is not matched by `*` or `?`
- `**` is shell- and library-dependent

---

## Wildcards (glob) — Python Example

**Scenario:** concatenate all log files from a directory

```python
from pathlib import Path

log_dir = Path("logs")
output = Path("all_logs.txt")

with output.open("w") as out:
    for log_file in sorted(log_dir.glob("*.log")):
        out.write(f"\n=== {log_file.name} ===\n")
        out.write(log_file.read_text())
```

---

## Wildcards (glob) — Bash Usage Examples

\footnotesize

```bash
ls *.txt # List all text files

rm *.tmp *.bak # Remove temporary files

gcc src/*.c -o app # Compile all C sources

tar -czf logs.tar.gz logs/2025-*.log # Archive logs by date

grep "ERROR" /var/log/app/app_*.log # Search errors in rotated logs

cp images/*.{png,jpg} backup/ # Copy all images

wc -l data_??.csv # Count lines in CSV files

ls src/**/test_*.py # Find test files recursively (bash ≥ 4)

ls [!.]* # Exclude hidden files
```

\normalsize

---

## Wildcards (glob) — Usage in Programming Languages

| Language | Import / Tool | Example usage |
|---------|---------------|---------------|
| Python | `import glob` | `glob.glob("*.txt")` |
| Python | `from pathlib import Path` | `Path(".").glob("*.py")` |
| Bash | shell builtin | `ls *.txt` |
| Make | implicit glob | `SRC = *.c` |
| C | `<glob.h>` | `glob("*.log", 0, NULL, &g)` |
| C++ | `<filesystem>` | `for (auto& p : fs::directory_iterator("."))` |
| C# | `System.IO` | `Directory.GetFiles(".", "*.txt")` |
| Java | `java.nio.file` | `Files.newDirectoryStream(p, "*.txt")` |
| JavaScript | `glob` (npm) | `glob("**/*.js", cb)` |
| Haskell | `System.FilePath.Glob` | `glob "*.hs"` |
| Rust | `glob` crate | `glob("**/*.rs")?` |
| Go | `path/filepath` | `filepath.Glob("*.md")` |

---

## Regular Expressions — Syntax Overview

::: columns
::: column

### Basic syntax

| Construct | Meaning | Example |
|----------|---------|---------|
| `a` | literal character | `cat` |
| `.` | any character | `c.t` |
| `*` | 0 or more | `a*` |
| `+` | 1 or more | `a+` |
| `?` | 0 or 1 | `colou?r` |
| `{n}` | exactly *n* | `\d{4}` |
| `{n,m}` | from *n* to *m* | `\w{2,5}` |
| `[]` | character class | `[A-Z_]` |
| `[^]` | negated class | `[^0-9]` |
| `^` | start of string | `^https?` |
| `$` | end of string | `\.txt$` |

:::

::: column

### Groups and composition

| Construct | Meaning | Example |
|----------|---------|---------|
| `(re)` | capturing group | `(ab)+` |
| `(?:re)` | non-capturing group | `(?:ab)+` |
| `|` | alternation | `cat|dog` |
| `{n,m}` | group repetition | `(ab){2,4}` |
| nested `()` | composition | `(a(bc))*` |
| `^…$` | full match | `^(ab)+$` |
| precedence | `* + ?` > concat > `|` | `ab|cd*` |

:::
:::

---

## Regular Expressions — Example, Groups (Python)

```python
import re

text = "user:alice id:42"

m = re.search(r"user:(\w+)\s+id:(\d+)", text)

m.group(0)   # full match
m.group(1)   # 'alice'
m.group(2)   # '42'
m.groups()   # ('alice', '42')
```

* groups define submatches
* alternation applies to whole group

---

## Python `re` Module — Overview

::: columns
::: column

### Main functions

\footnotesize

| Function | Purpose | Notes |
|---------|---------|-------|
| `re.match()` | match at start | implicit `^` |
| `re.search()` | find first match | most common |
| `re.findall()` | find all matches | returns list |
| `re.finditer()` | match iterator | memory-efficient |
| `re.fullmatch()` | full string match | implicit `^...$` |
| `re.split()` | split string | regex delimiter |
| `re.sub()` | replace matches | supports groups |
| `re.compile()` | compile pattern | reuse + flags |

\normalsize

:::

::: column

### Flags and notes

**Flags**
- `re.IGNORECASE` / `re.I`
- `re.MULTILINE` / `re.M`
- `re.DOTALL` / `re.S`
- `re.VERBOSE` / `re.X`

**Engine**
- backtracking NFA
- possible exponential behavior

**Practice**
- prefer raw strings: `r"..."`

:::
:::

---

## Regular Expressions — Basic Syntax (Python)

```python
import re

text = "Error 404 at line 23"

re.search(r"\d+", text)          # match number
# <re.Match object; span=(6, 9), match='404'>

re.findall(r"[A-Z][a-z]+", text) # words starting with capital
# ['Error']

re.match(r"Error", text)         # match at start
# <re.Match object; span=(0, 5), match='Error'>

re.fullmatch(r".*\d{2}", text)   # full string match
# <re.Match object; span=(0, 20), match='Error 404 at line 23'>
````
---

## Regular Expressions — Usage in Programming Languages

**Example pattern:** match a sequence of digits (`[0-9]+`)

| Language | Import / Tool | Example usage |
|---------|---------------|---------------|
| Python | `import re` | `re.search(r"[0-9]+", text)` |
| Bash | `grep -E` | `grep -E "[0-9]+" file` |
| Bash | `sed` | `sed -n '/[0-9]+/p' file` |
| C | `<regex.h>` | `regexec(&re, str, 0, NULL, 0)` |
| C++ | `<regex>` | `std::regex_search(s, std::regex("[0-9]+"))` |
| C# | `System.Text.RegularExpressions` | `Regex.Match(s, "[0-9]+")` |
| Java | `java.util.regex` | `Pattern.compile("[0-9]+").matcher(s)` |
| JavaScript | built-in | `text.match(/[0-9]+/)` |
| Rust | `regex` crate | `Regex::new("[0-9]+")?.is_match(text)` |
| Go | `regexp` | `regexp.MatchString("[0-9]+", s)` |
| Haskell | `regex-tdfa` | `text =~ "[0-9]+"` |

- same logical pattern across languages
- syntax and API differ
- engine behavior may differ

---

## `sed` — Stream Editor

::: columns
::: column

### Theory and model

- Line-oriented stream editor
- Processes input sequentially
- Regex-driven commands
- No global memory
- Designed for text transformation
- Typical operations: substitute, delete, print

:::

::: column

### Examples

```bash
# Substitute numbers
sed 's/[0-9]\+/NUM/g' file.txt
````

```bash
# Print matching lines
sed -n '/ERROR/p' app.log
```

```bash
# Delete comments
sed '/^#/d' config.conf
```

```bash
# In-place edit
sed -i 's/foo/bar/g' *.txt
```

:::
:::

---

## `awk` — Pattern–Action Language

::: columns
::: column

### Theory and model

* Line-based processing language
* Regex as conditions
* Automatic field splitting
* Variables and expressions
* Implicit loop over lines
* Small programs, not just filters

:::

::: column

### Examples

```bash
# Print selected fields
awk '{print $1, $3}' data.txt
```

```bash
# Filter by regex
awk '/ERROR/ {print}' app.log
```

```bash
# Simple condition
awk '$3 > 100 {print $1}' table.txt
```

```bash
# Custom separator
awk -F: '{print $1}' /etc/passwd
```

:::
:::

---

## `awk` + `sed` — Combined Usage Example

**Process application logs:** extract error records and anonymize numeric values

```bash
awk '/ERROR/ {print $2, $0}' app.log | sed 's/[0-9]\+/NUM/g'
````

::: columns
::: column

### Explanation

* `awk '/ERROR/ {print $2, $0}'`

  * selects only lines containing `ERROR`
  * prints second field (e.g. module name)
  * keeps the full original line

* `sed 's/[0-9]\+/NUM/g'`

  * replaces all numbers
  * removes IDs, counters, timestamps

:::
::: column

### Example

Input:

```
2025-01-30 ERROR auth failed after 3 attempts
```

Output:

```
auth 2025-01-30 ERROR auth failed after NUM attempts
```

* `awk` → filtering and restructuring
* `sed` → text normalization

:::
:::

---

