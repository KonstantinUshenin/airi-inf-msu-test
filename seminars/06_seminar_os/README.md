# Семинар 6. Unix-terminal. Работа с оборудованием

## Цель

Научиться инспектировать оборудование и ресурсы ОС из терминала и из Python: блочные устройства, PCI/USB, память и CPU через `/proc`, GPU, а также запускать внешние программы (subprocess, fork) и анализировать системные вызовы (strace). Результаты фиксировать в отчёте, артефакты сохранять на диске.

## Теоретический минимум

- **Блочные и символьные устройства:** `/dev/sda`, `/dev/nvme0n1` — блочные (файловые системы); устройство как файл (лекция: device drivers, I/O).
- **Разделы и монтирование:** таблица разделов (GPT/MBR), `mount`, точки монтирования, корневая ФС.
- **Шина PCI и USB:** как ОС видит железо; драйверы и модули ядра.
- **Псевдо-ФС `/proc`:** виртуальные файлы с данными ядра и процессов: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/PID/status`, `/proc/PID/maps`, `/proc/PID/fd/` (лекция: strace and /proc).
- **Системные вызовы и strace:** как программа общается с ядром (read/write/open…), зачем нужен strace для отладки и профилирования.
- **Процессы:** `fork()` создаёт копию процесса, copy-on-write; типичный сценарий `fork()` + `exec()` для запуска другой программы (лекция: process lifecycle, CoW fork).

## Задачи

1. **Блочные устройства и разделы**
   - Вывести дерево блочных устройств: `lsblk` (с опциями для размера, типа, UUID, точек монтирования).
   - Определить, на каком разделе смонтирована корневая ФС и какая у неё файловая система.
   - С помощью `fdisk -l` (или `lsblk -f`) описать таблицу разделов одного из дисков: тип раздела, размер, назначение.
   - Результаты (вывод команд) сохранить в отчёт; скрин или текстовый вывод — в артефакты.

2. **PCI и USB**
   - Вывести список устройств PCI с подробностями: `lspci -v` (или `-vv`); найти сетевой адаптер и дисковый контроллер, записать производителя и модель.
   - Вывести список USB-устройств: `lsusb` (при необходимости `lsusb -v`); описать одно устройство (класс, производитель, ID).
   - Фрагменты вывода сохранить в отчёт/артефакты.

3. **Информация о CPU и памяти через `/proc`**
   - Прочитать `/proc/cpuinfo`: модель CPU, число ядер/процессоров, флаги (например, наличие виртуализации).
   - Прочитать `/proc/meminfo`: всего RAM, свободно, кэш, swap (понять, что означают MemTotal, MemFree, Cached, SwapTotal/SwapFree).
   - Кратко описать в отчёте, как эти данные связаны с лекцией (виртуальная память, планировщик).

4. **GPU (если доступно)**
   - Вывести информацию о GPU и загрузке: `nvidia-smi` (драйвер, версия CUDA, использование памяти, процессы).
   - При наличии установленного `nvtop` — зафиксировать вывод (загрузка по устройствам).
   - Если GPU нет — описать в отчёте и пропустить или выполнить на удалённом сервере с GPU.

5. **Монтирование**
   - Вывести список смонтированных ФС: `mount` или `findmnt`; определить тип ФС для корня и для одного из разделов (например, `/home` или временные).
   - Кратко связать с лекцией: корневая ФС при загрузке, initrd/initramfs (если упоминалось).

6. **Подключение нового диска и автоматическое монтирование**
   - Подключить новый диск (или использовать отдельный раздел / флешку; при необходимости — в виртуальной машине или на учебном сервере по указанию преподавателя).
   - При необходимости: создать раздел (`fdisk`/`gdisk`) и файловую систему (`mkfs.ext4` или аналог).
   - Настроить автоматическое монтирование при загрузке: добавить запись в `/etc/fstab` (рекомендуется использовать UUID — `blkid` — или LABEL, чтобы не зависеть от имени устройства).
   - Создать точку монтирования (например, `/mnt/seminar_disk`), смонтировать диск вручную (`mount -a` или `mount /mnt/seminar_disk`).
   - Создать на смонтированном диске тестовый файл с известным содержимым (или использовать уже имеющийся файл).
   - Прочитать содержимое этого файла и записать его в отчёт, а также сохранить в файл на другой файловой системе (например, в домашний каталог или в каталог с артефактами семинара).
   - После перезагрузки проверить, что диск смонтировался автоматически и файл доступен; при успехе — зафиксировать в отчёте (вывод `mount`/`findmnt` после загрузки).

7. **Python: argparse и subprocess**
   - Написать скрипт на Python, который:
     - принимает аргументы командной строки через `argparse` (например, флаг `--cpu`, `--mem`, `--gpu`);
     - в зависимости от флага запускает одну из утилит: чтение `/proc/cpuinfo` или `/proc/meminfo` (через открытие файла или `subprocess.run` с `cat`), или `nvidia-smi`, или `lspci`;
     - выводит результат в stdout.
   - Сохранить скрипт в репозиторий/ноутбук и фрагмент вывода в отчёт.

8. **fork и запуск дочернего процесса**
   - Написать небольшую программу на C или Python (с `os.fork()` или модулем `subprocess`):
     - в случае C: после `fork()` в дочернем процессе вызвать `exec()` (например, `execlp("ls", "ls", "-l", NULL)`), в родителе — `wait()` и вывести сообщение о завершении;
     - в случае Python: использовать `subprocess.run` или `os.fork()` + `os.exec*` по аналогии с лекцией.
   - Объяснить в отчёте: зачем нужен fork+exec, что такое зомби-процесс и как его избежать (wait).

9. **strace и неизвестный бинарник**
   - Преподаватель выдаёт исполняемый файл (бинарник), который запускается, но его поведение не документировано — студенты не знают, что он делает (читает файлы, обращается к сети, выводит ключ и т.п.).
   - Запустить бинарник под `strace` (при необходимости с `-f` для отслеживания fork, `-e trace=read,write,openat,...` для фильтрации вызовов).
   - По системным вызовам определить, что делает программа: какие файлы открывает/читает, идёт ли обращение к сети (например, `connect`, `sendto`, `recvfrom`), что выводится в stdout/stderr.
   - Найти в поведении программы **ключ** или итоговый результат (например, строка, которую программа печатает или записывает в файл) и зафиксировать его: сохранить в файл в каталоге артефактов и/или привести в отчёте.
   - Кратко описать в отчёте: какие системные вызовы позволили понять поведение бинарника; при желании — фрагмент вывода `strace` (или `strace -c`) сохранить в артефакты.

Отчёт и артефакты (скрипты, выводы команд) хранить в репозитории семинара или в Jupyter-ноутбуке / на удалённом сервере по указанию преподавателя.

## Бонусные задачи

- **Реверс-инжиниринг бинарника:** установить и освоить основы [radare2](https://github.com/radareorg/radare2): открыть простой ELF-исполняемый файл, просмотреть заголовки (`r2 -A ./program`), список секций, точку входа; кратко описать в отчёте связь с лекцией (ELF, .text/.data, динамическая линковка). Модифицировать бинарник так, чтобы он начал выводить "Вы получили бонусные баллы" при любом входе (при этом оригиинальный бинарник должен это выводить только если студент отгадает ключ).
- **strace и fork:** запустить под strace программу из задания 8 (fork+exec); объяснить в отчёте, какие системные вызовы соответствуют `fork`, `exec` и `wait`, и как по выводу strace отличить родителя и потомка.
